Index: object.di
===================================================================
--- object.di	(revision 3831)
+++ object.di	(working copy)
@@ -150,6 +150,9 @@
     void function() dtor;
     void function() unitTest;
 
+    void* xgetMembers;
+    void function() ictor;
+
     static int opApply( int delegate( inout ModuleInfo ) );
 }
 
Index: lib/common/tango/core/BitManip.d
===================================================================
--- lib/common/tango/core/BitManip.d	(revision 3831)
+++ lib/common/tango/core/BitManip.d	(working copy)
@@ -171,6 +171,10 @@
      */
     uint outpl( uint port_address, uint value );
 }
+else version( LLVMDC )
+{
+    public import llvmdc.bitmanip;
+}
 else
 {
     public import std.intrinsic;
Index: lib/common/tango/core/Thread.d
===================================================================
--- lib/common/tango/core/Thread.d	(revision 3831)
+++ lib/common/tango/core/Thread.d	(working copy)
@@ -244,10 +244,33 @@
         }
         body
         {
-            version( D_InlineAsm_X86 )
+            version( LLVMDC )
             {
+                // put registers on the stack
+                version(D_InlineAsm_X86)
+                {
+                uint _eax, _ecx, _edx, _ebx, _esp, _ebp, _esi, _edi;
                 asm
                 {
+                    mov _eax, EAX;
+                    mov _ecx, ECX;
+                    mov _edx, EDX;
+                    mov _ebx, EBX;
+                    mov _esp, ESP;
+                    mov _ebp, EBP;
+                    mov _esi, ESI;
+                    mov _edi, EDI;
+                }
+                }
+                else
+                {
+                    // FIXME
+                }
+            }
+            else version( D_InlineAsm_X86 )
+            {
+                asm
+                {
                     pushad;
                 }
             }
@@ -297,8 +320,12 @@
                 }
             }
 
-            version( D_InlineAsm_X86 )
+            version( LLVMDC )
             {
+                // nothing to do
+            }
+            else version( D_InlineAsm_X86 )
+            {
                 asm
                 {
                     popad;
@@ -2266,8 +2293,12 @@
 
 private
 {
-    version( D_InlineAsm_X86 )
+    version( LLVMDC )
     {
+
+    }
+    else version( D_InlineAsm_X86 )
+    {
         version( X86_64 )
         {
 
Index: lib/unittest.sh
===================================================================
--- lib/unittest.sh	(revision 3831)
+++ lib/unittest.sh	(working copy)
@@ -18,8 +18,9 @@
   --help: This message
   --run-all: Reports result instead of breaking. Do not use this if you want to
          run unittest runner through a debugger.
-  dmd: Builds unittests for dmd
-  gdc: Builds unittests for gdc
+  dmd:    Builds unittests for dmd
+  gdc:    Builds unittests for gdc
+  llvmdc: Builds unittests for llvmdc
 
   <none>: Builds unittests for all known compilers.'
   exit 0
@@ -125,6 +126,9 @@
         gdc)
             GDC=1
             ;;
+        llvmdc)
+            LLVMDC=1
+            ;;
         *)
             usage
             ;;
@@ -132,10 +136,11 @@
     shift
 done
 
-if [ ! "$DMD" -a ! "$GDC" ]
+if [ ! "$DMD" -a ! "$GDC" -a ! "$LLVMDC" ]
 then
     DMD=1
     GDC=1
+    LLVMDC=1
 fi
 
 if [ "$DMD" = "1" ]
@@ -146,4 +151,7 @@
 then
     compile gdc runUnitTest_gdc
 fi
-
+if [ "$LLVMDC" = "1" ]
+then
+    compile llvmdc runUnitTest_llvmdc
+fi
Index: lib/gc/basic/gcx.d
===================================================================
--- lib/gc/basic/gcx.d	(revision 3831)
+++ lib/gc/basic/gcx.d	(working copy)
@@ -2178,6 +2178,28 @@
             __builtin_unwind_init();
             sp = & sp;
         }
+        else version(LLVMDC)
+        {
+            version(D_InlineAsm_X86)
+            {
+            uint _eax, _ecx, _edx, _ebx, _ebp, _esi, _edi;
+            asm
+            {
+                mov _eax, EAX;
+                mov _ecx, ECX;
+                mov _edx, EDX;
+                mov _ebx, EBX;
+                mov _ebp, EBP;
+                mov _esi, ESI;
+                mov _edi, EDI;
+                mov sp, ESP;
+            }
+            }
+            else
+            {
+                // FIXME
+            }
+        }
         else
         {
         asm
@@ -2191,6 +2213,10 @@
         {
             // nothing to do
         }
+        else version(LLVMDC)
+        {
+            // nothing to do
+        }
         else
         {
         asm
Index: lib/gc/basic/gcbits.d
===================================================================
--- lib/gc/basic/gcbits.d	(revision 3831)
+++ lib/gc/basic/gcbits.d	(working copy)
@@ -39,6 +39,10 @@
 {
     // use the unoptimized version
 }
+else version(LLVMDC)
+{
+    // ditto
+}
 else version (D_InlineAsm_X86)
 {
     version = Asm86;
Index: tango/text/convert/Layout.d
===================================================================
--- tango/text/convert/Layout.d	(revision 3831)
+++ tango/text/convert/Layout.d	(working copy)
@@ -47,6 +47,12 @@
         alias void* Arg;
         alias va_list ArgList;
         }
+else version(LLVMDC)
+        {
+        private import tango.core.Vararg;
+        alias void* Arg;
+        alias va_list ArgList;
+        }
      else
         {
         alias void* Arg;
@@ -197,9 +203,18 @@
                 assert (formatStr, "null format specifier");
                 assert (arguments.length < 64, "too many args in Layout.convert");
 
-                version (GNU)
+                version (LLVMDC)
                         {
                         Arg[64] arglist = void;
+                        foreach (i, arg; arguments)
+                                {
+                                arglist[i] = args;
+                                args += (arg.tsize + size_t.sizeof - 1) & ~ (size_t.sizeof - 1);
+                                }
+                        }
+                else version (GNU)
+                        {
+                        Arg[64] arglist = void;
                         int[64] intargs = void;
                         byte[64] byteargs = void;
                         long[64] longargs = void;
Index: tango/core/Vararg.d
===================================================================
--- tango/core/Vararg.d	(revision 3831)
+++ tango/core/Vararg.d	(working copy)
@@ -15,6 +15,10 @@
 {
     public import std.stdarg;
 }
+else version( LLVMDC )
+{
+    public import llvmdc.vararg;
+}
 else
 {
     /**
Index: tango/math/Math.d
===================================================================
--- tango/math/Math.d	(revision 3831)
+++ tango/math/Math.d	(working copy)
@@ -76,6 +76,14 @@
         version = DigitalMars_D_InlineAsm_X86;
     }
 }
+else version(LLVMDC)
+{
+    import llvmdc.intrinsics;
+    version(X86)
+    {
+        version = LLVMDC_X86;
+    }
+}
 
 /*
  * Constants
@@ -298,6 +306,24 @@
  * Bugs:
  *  Results are undefined if |x| >= $(POWER 2,64).
  */
+version(LLVMDC)
+{
+    alias llvm_cos_f32 cos;
+    alias llvm_cos_f64 cos;
+    version(X86)
+    {
+        alias llvm_cos_f80 cos;
+    }
+    else
+    {
+        real cos(real x)
+        {
+            return tango.stdc.math.cosl(x);
+        }
+    }
+}
+else
+{
 real cos(real x) /* intrinsic */
 {
     version(D_InlineAsm_X86)
@@ -313,6 +339,7 @@
         return tango.stdc.math.cosl(x);
     }
 }
+}
 
 debug(UnitTest) {
 unittest {
@@ -333,6 +360,24 @@
  * Bugs:
  *  Results are undefined if |x| >= $(POWER 2,64).
  */
+version(LLVMDC)
+{
+    alias llvm_sin_f32 sin;
+    alias llvm_sin_f64 sin;
+    version(X86)
+    {
+        alias llvm_sin_f80 sin;
+    }
+    else
+    {
+        real sin(real x)
+        {
+            return tango.stdc.math.sinl(x);
+        }
+    }
+}
+else
+{
 real sin(real x) /* intrinsic */
 {
     version(D_InlineAsm_X86)
@@ -348,6 +393,7 @@
         return tango.stdc.math.sinl(x);
     }
 }
+}
 
 debug(UnitTest) {
 unittest {
@@ -374,7 +420,11 @@
 {
     version (GNU) {
         return tanl(x);
-    } else {
+    }
+    else version(LLVMDC) {
+        return tango.stdc.math.tanl(x);
+    }
+    else {
     asm
     {
         fld x[EBP]      ; // load theta
@@ -947,6 +997,25 @@
  *  <tr> <td> +&infin; <td> +&infin; <td> no
  *  )
  */
+version(LLVMDC)
+{
+    alias llvm_sqrt_f32 sqrt;
+    alias llvm_sqrt_f64 sqrt;
+    version(X86)
+    {
+        alias llvm_sqrt_f80 sqrt;
+    }
+    else
+    {
+        real sqrt(real x)
+        {
+            return tango.stdc.math.sqrtl(x);
+        }
+    }
+}
+else
+{
+
 float sqrt(float x) /* intrinsic */
 {
     version(D_InlineAsm_X86)
@@ -995,6 +1064,8 @@
     }
 }
 
+}
+
 /** ditto */
 creal sqrt(creal z)
 {
@@ -1477,7 +1548,14 @@
         }
     }
     }
-    return tango.stdc.math.powl(x, y);
+    version(LLVMDC_X86)
+    {
+        return llvm_pow_f80(x, y);
+    }
+    else
+    {
+        return tango.stdc.math.powl(x, y);
+    }
 }
 
 debug(UnitTest) {
Index: tango/stdc/stdlib.d
===================================================================
--- tango/stdc/stdlib.d	(revision 3831)
+++ tango/stdc/stdlib.d	(working copy)
@@ -94,6 +94,11 @@
 {
     void* alloca(size_t size);
 }
+else version( LLVMDC )
+{
+    pragma(alloca)
+        void* alloca(size_t size);
+}
 else version( GNU )
 {
     private import gcc.builtins;
Index: tango/stdc/stdarg.d
===================================================================
--- tango/stdc/stdarg.d	(revision 3831)
+++ tango/stdc/stdarg.d	(working copy)
@@ -13,6 +13,10 @@
 {
     public import std.c.stdarg;
 }
+else version( LLVMDC )
+{
+    public import llvmdc.cstdarg;
+}
 else
 {
     alias void* va_list;
