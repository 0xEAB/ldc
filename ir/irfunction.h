//===-- ir/irfunction.h - Codegen state for D functions ---------*- C++ -*-===//
//
//                         LDC â€“ the LLVM D compiler
//
// This file is distributed under the BSD-style LDC license. See the LICENSE
// file for details.
//
//===----------------------------------------------------------------------===//
//
// Represents the status of a D function/method/... on its way through the
// codegen process.
//
//===----------------------------------------------------------------------===//


#ifndef LDC_IR_IRFUNCTION_H
#define LDC_IR_IRFUNCTION_H

#include "llvm/ADT/DenseMap.h"
#include "llvm/ADT/DenseMapInfo.h"
#include "gen/llvm.h"
#include "ir/irfuncty.h"
#include <map>
#include <stack>
#include <vector>

class Identifier;
class Statement;
struct IRState;

/// Represents a position on the stack of currently active cleanup scopes.
///
/// Since we always need to run a contiguous part of the stack (or all) in
/// order, this is enough to uniquely identify the location of a given target.
typedef size_t CleanupCursor;

/// Stores information needed to correctly jump to a given label or loop
/// statement (break/continue).
struct JumpTarget {
    /// The basic block to ultimately branch to.
    llvm::BasicBlock* targetBlock;

    /// The index of the label target in the stack of active cleanup scopes.
    ///
    /// When generating code for a jump to this label, the cleanups between
    /// the current depth and that of the level will be emitted. Note that
    /// we need to handle only one direction (towards the root of the stack)
    /// because D forbids gotos into try or finally blocks.
    // TODO: We might not be able to detect illegal jumps across try-finally
    // blocks by only storing the index.
    CleanupCursor cleanupScope;

    /// Keeps target of the associated loop or switch statement so we can
    /// handle both unlabeled and labeled jumps.
    Statement* targetStatement;
};

/// Defines source and target label of a goto (used if we cannot immediately
/// figure out the target basic block).
struct GotoJump {
    // The location of the jump instruction, for error reporting.
    Loc sourceLoc;

    /// The basic block which contains the goto as its terminator.
    llvm::BasicBlock* sourceBlock;

    /// While we have not found the actual branch target, we might need to
    /// create a "fake" basic block in order to be able to execute the cleanups
    /// (we do not keep branching information around after leaving the scope).
    llvm::BasicBlock* tentativeTarget;

    /// The label to target with the goto.
    Identifier* targetLabel;
};

/// Describes a particular way to leave a certain scope and continue execution
/// at another one (return, break/continue, exception handling, etc.).
struct CleanupExitTarget {
    explicit CleanupExitTarget(llvm::BasicBlock* t) : branchTarget(t) {}

    /// The target basic block to branch to after running the cleanup.
    llvm::BasicBlock* branchTarget;

    /// The basic blocks that want to continue with this target after running
    /// the cleanup. We need to keep this information around so we can insert
    /// stores to the branch selector variable when converting from one to two
    /// targets.
    std::vector<llvm::BasicBlock*> sourceBlocks;
};

/// Represents a scope (in abstract terms, not curly braces) that requires a
/// piece of cleanup code to be run whenever it is left, whether as part of
/// normal control flow or exception unwinding.
///
/// This includes finally blocks (which are also generated by the frontend for
/// running the destructors of non-temporary variables) and the destructors of
/// temporaries (which are unfortunately not lowered by the frontend).
///
/// Our goal is to only emit each cleanup once such as to avoid generating an
/// exponential number of basic blocks/landing pads for handling all the
/// different ways of exiting a deeply nested scope (exception/no exception/...).
class CleanupScope {
public:
    CleanupScope(llvm::BasicBlock* beginBlock, llvm::BasicBlock* endBlock) :
        beginBlock(beginBlock), endBlock(endBlock), branchSelector(0) {}

    /// The basic block to branch to for running the cleanup.
    llvm::BasicBlock* beginBlock;

    /// The basic block that contains the end of the cleanuip code (is different
    /// from beginBlock if the cleanup contains control flow).
    llvm::BasicBlock* endBlock;

    /// The branch selector variable, or null if not created yet.
    llvm::AllocaInst* branchSelector;

    /// Stores all possible targets blocks after running this cleanup, along
    /// with what predecessors want to continue at that target. The index in
    /// the vector corresponds to the branch selector value for that target.
    std::vector<CleanupExitTarget> exitTargets;

    /// Keeps track of all the gotos somewhere inside this scope for which we
    /// have not found the label yet (because it occurs lexically later in the
    /// function).
    std::vector<GotoJump> unresolvedGotos;
};

/// Contains transitory information about the current scope, etc. while
/// traversing the function for codegen purposes.
class ScopeStack {
public:
    ScopeStack(IRState *irs) : irs(irs) {}
    ~ScopeStack();

    /// Registers a piece of cleanup code to be run.
    ///
    /// The basic block is expected not to contain a terminator yet. It will be
    /// added by ScopeStack as needed based on what followup blocks there will be
    /// registered.
    void pushCleanup(llvm::BasicBlock* beginBlock, llvm::BasicBlock* endBlock);

    /// Terminates the current IRScope with a branch to the cleanups needed for
    /// leaving the given scope and continuing execution at the target scope
    /// stack level.
    ///
    /// After running them, execution will branch to the given basic block.
    void runCleanups(CleanupCursor targetScope, llvm::BasicBlock* continueWith);

    /// Like #runCleanups(), but runs all of them.
    void runAllCleanups(llvm::BasicBlock* continueWith);

    /// Pops all the cleanups between the current scope and the target cursor.
    void popCleanups(CleanupCursor targetScope);

    /// Returns a cursor that identifies the curernt cleanup scope, to be later
    /// userd with #popCleanups() et al.
    ///
    /// Note that this cursor is only valid as long as the current scope is not
    /// popped.
    CleanupCursor currentCleanupScope() { return cleanupScopes.size(); }

#if 0
    void suspendCleanup(CleanupCursor target);

    void resumeCleanup(CleanupCursor target);
#endif

    ///
    void pushCatch(llvm::Value* classInfoPtr, llvm::Value* exceptionVar,
        llvm::BasicBlock* bodyBlock) {}

    ///
    void popCatch() {}

    ///
    void pushLoopTarget(Statement* loopStatement, llvm::BasicBlock* continueTarget,
        llvm::BasicBlock* breakTarget);

    /// Pops the last pushed loop target, so it is no longer taken into
    /// consideration for resolving breaks/continues.
    void popLoopTarget();

    ///
    void pushBreakTarget(Statement* switchStatement, llvm::BasicBlock* targetBlock);

    ///
    void popBreakTarget();

    ///
    void addLabelTarget(Identifier* labelName, llvm::BasicBlock* targetBlock);

    ///
    void jumpToLabel(Loc loc, Identifier* labelName);

    ///
    void continueWithLoop(Statement* loopStatement) {
        jumpToStatement(continueTargets, loopStatement);
    }

    ///
    void continueWithClosest() {
        jumpToClosest(continueTargets);
    }

    ///
    void breakToStatement(Statement* loopOrSwitchStatement) {
        jumpToStatement(breakTargets, loopOrSwitchStatement);
    }

    ///
    void breakToClosest() {
        jumpToClosest(breakTargets);
    }

private:
    std::vector<GotoJump>& currentUnresolvedGotos();

    void jumpToStatement(std::vector<JumpTarget>& targets, Statement* loopOrSwitchStatement);

    void jumpToClosest(std::vector<JumpTarget>& targets);

    IRState *irs;

    typedef llvm::DenseMap<Identifier*, JumpTarget> LabelTargetMap;
    /// The labels we have encountered in this function so far, accessed by
    /// their associated identifier (i.e. the name of the label).
    LabelTargetMap labelTargets;

    ///
    std::vector<JumpTarget> breakTargets;

    ///
    std::vector<JumpTarget> continueTargets;

    ///
    std::vector<CleanupScope> cleanupScopes;

    /// Gotos which we were not able to resolve to any cleanup scope, but which
    /// might still be defined later in the function at top level. If there are
    /// any left on function exit, it is an error (e.g. because the user tried
    /// to goto into a finally block, etc.).
    std::vector<GotoJump> topLevelUnresolvedGotos;

#if 0
    /// To be able to handle the broken AST the frontend produces in some cases
    /// for temporary constructor calls, we need to be able to temporarily
    /// suspend a cleanup from being run without removing it from the stack.
    // FIXME: Make sure this does not break our usual assumption that all
    // temporaries are run all the time.
    std::vector<CleanupCursor> suspendedCleanups;
#endif
};

// represents a function
struct IrFunction {
    // constructor
    IrFunction(FuncDeclaration* fd);

    // annotations
    void setNeverInline();
    void setAlwaysInline();

    llvm::Function* func;
    llvm::Instruction* allocapoint;
    FuncDeclaration* decl;
    TypeFunction* type;

    ScopeStack* scopes;

    bool queued;
    bool defined;

    llvm::Value* retArg; // return in ptr arg
    llvm::Value* thisArg; // class/struct 'this' arg
    llvm::Value* nestArg; // nested function 'this' arg

    llvm::Value* nestedVar; // alloca for the nested context of this function
    llvm::StructType* frameType; // type of nested context
    // number of enclosing functions with variables accessed by nested functions
    // (-1 if neither this function nor any enclosing ones access variables from enclosing functions)
    int depth;
    bool nestedContextCreated; // holds whether nested context is created

    llvm::Value* _arguments;
    llvm::Value* _argptr;

    // A stack slot containing the return value, for functions that return by value.
    llvm::AllocaInst* retValSlot;
    // The basic block with the return instruction.
    llvm::BasicBlock* retBlock;

#if LDC_LLVM_VER >= 307
    llvm::DISubprogram* diSubprogram = nullptr;
    std::stack<llvm::DILexicalBlock*> diLexicalBlocks;
    typedef llvm::DenseMap<VarDeclaration*, llvm::DILocalVariable*> VariableMap;
#else
    llvm::DISubprogram diSubprogram;
    std::stack<llvm::DILexicalBlock> diLexicalBlocks;
    typedef llvm::DenseMap<VarDeclaration*, llvm::DIVariable> VariableMap;
#endif
    // Debug info for all variables
    VariableMap variableMap;

    IrFuncTy irFty;
};

IrFunction *getIrFunc(FuncDeclaration *decl, bool create = false);
bool isIrFuncCreated(FuncDeclaration *decl);

#endif
