diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/import/object.di druntime/import/object.di
--- druntime-orig/import/object.di	2010-09-03 12:28:52.000000000 +0400
+++ druntime/import/object.di	2010-10-27 00:22:27.444925001 +0400
@@ -130,7 +130,7 @@
     Interface[] interfaces;
     TypeInfo_Class   base;
     void*       destructor;
-    void(*classInvariant)(Object);
+    void function(Object) classInvariant;
     uint        m_flags;
     //  1:      // is IUnknown or is derived from IUnknown
     //  2:      // has no possible pointers into GC memory
@@ -140,7 +140,7 @@
     // 32:      // has typeinfo member
     void*       deallocator;
     OffsetTypeInfo[] m_offTi;
-    void*       defaultConstructor;
+    void function(Object) defaultConstructor;   // default Constructor
     const(MemberInfo[]) function(string) xgetMembers;
 
     static TypeInfo_Class find(in char[] classname);
@@ -179,7 +179,7 @@
 
 class TypeInfo_Const : TypeInfo
 {
-    TypeInfo next;
+    TypeInfo base;
 }
 
 class TypeInfo_Invariant : TypeInfo_Const
@@ -288,7 +288,6 @@
     interface TraceInfo
     {
         int opApply(scope int delegate(ref char[]));
-        string toString();
     }
 
     string      msg;
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/core/atomic.d druntime/src/core/atomic.d
--- druntime-orig/src/core/atomic.d	2010-09-03 12:28:52.000000000 +0400
+++ druntime/src/core/atomic.d	2010-10-05 15:55:10.893150001 +0400
@@ -89,6 +89,117 @@
          return false;
      }
 }
+
+////////////////////////////////////////////////////////////////////////////////
+// LDC Atomics Implementation
+////////////////////////////////////////////////////////////////////////////////
+
+else version( LDC )
+{
+    import ldc.intrinsics;
+
+    T atomicOp(string op, T, V1)( ref shared T val, V1 mod )
+        if( is( NakedType!(V1) == NakedType!(T) ) )
+    {
+        // binary operators
+        //
+        // +    -   *   /   %   ^^  &
+        // |    ^   <<  >>  >>> ~   in
+        // ==   !=  <   <=  >   >=
+        static if( op == "+"  || op == "-"  || op == "*"  || op == "/"   ||
+                   op == "%"  || op == "^^" || op == "&"  || op == "|"   ||
+                   op == "^"  || op == "<<" || op == ">>" || op == ">>>" ||
+                   op == "~"  || // skip "in"
+                   op == "==" || op == "!=" || op == "<"  || op == "<="  ||
+                   op == ">"  || op == ">=" )
+        {
+            T get = val; // compiler can do atomic load
+            mixin( "return get " ~ op ~ " mod;" );
+        }
+        else
+        // assignment operators
+        //
+        // +=   -=  *=  /=  %=  ^^= &=
+        // |=   ^=  <<= >>= >>>=    ~=
+        static if( op == "+=" || op == "-="  || op == "*="  || op == "/=" ||
+                   op == "%=" || op == "^^=" || op == "&="  || op == "|=" ||
+                   op == "^=" || op == "<<=" || op == ">>=" || op == ">>>=" ) // skip "~="
+        {
+            T get, set;
+            
+            do
+            {
+                get = set = atomicLoad!(msync.raw)( val );
+                mixin( "set " ~ op ~ " mod;" );
+            } while( !cas( &val, get, set ) );
+            return set;
+        }
+        else
+        {
+            static assert( false, "Operation not supported." );
+        }
+    }  
+
+    bool cas(T,V1,V2)( shared(T)* here, const V1 ifThis, const V2 writeThis )
+        if( is( NakedType!(V1) == NakedType!(T) ) &&
+            is( NakedType!(V2) == NakedType!(T) ) )
+
+    {
+        T oldval = void;
+        static if (is(T P == U*, U))
+        {
+            oldval = cast(T)llvm_atomic_cmp_swap!(size_t)(cast(shared size_t*)&writeThis, cast(size_t)ifThis, cast(size_t)here);
+        }
+        else static if (is(T == bool))
+        {
+            oldval = llvm_atomic_cmp_swap!(ubyte)(cast(shared ubyte*)&writeThis, ifThis?1:0, here?1:0)?0:1;
+        }
+        else
+        {
+            oldval = llvm_atomic_cmp_swap!(T)(here, ifThis, writeThis);
+        }
+        return oldval == ifThis;
+    }
+
+
+    private
+    {
+        enum msync
+        {
+            raw,    /// not sequenced
+            acq,    /// hoist-load + hoist-store barrier
+            rel,    /// sink-load + sink-store barrier
+            seq,    /// fully sequenced (acq + rel)
+        }
+
+        T atomicLoad(msync ms = msync.seq, T)( const ref shared T val )
+        {
+            llvm_memory_barrier(
+                ms == msync.acq || ms == msync.seq,
+                ms == msync.acq || ms == msync.seq,
+                ms == msync.rel || ms == msync.seq,
+                ms == msync.rel || ms == msync.seq,
+                false);
+            static if (is(T P == U*, U)) // pointer
+            {
+                return cast(T)llvm_atomic_load_add!(size_t)(cast(size_t*)&val, 0);
+            }
+            else static if (is(T == bool))
+            {
+                return llvm_atomic_load_add!(ubyte)(cast(ubyte*)&val, cast(ubyte)0) ? 1 : 0;
+            }
+            else
+            {
+                return llvm_atomic_load_add!(T)(&val, cast(T)0);
+            }
+        }
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// x86_32 Atomic Function Implementation
+////////////////////////////////////////////////////////////////////////////////
+
 else version( AsmX86_32 )
 {
     T atomicOp(string op, T, V1)( ref shared T val, V1 mod )
@@ -396,6 +507,12 @@
         }
     }
 }
+
+
+////////////////////////////////////////////////////////////////////////////////
+// x86_64 Atomic Function Implementation
+////////////////////////////////////////////////////////////////////////////////
+
 else version( AsmX86_64 )
 {
     T atomicOp(string op, T, V1)( ref shared T val, V1 mod )
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/core/stdc/math.d druntime/src/core/stdc/math.d
--- druntime-orig/src/core/stdc/math.d	2010-09-03 12:28:52.000000000 +0400
+++ druntime/src/core/stdc/math.d	2010-10-26 16:47:04.036925000 +0400
@@ -17,6 +17,7 @@
 
 extern (C):
 nothrow:
+pure: // LDC
 
 alias float  float_t;
 alias double double_t;
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/core/stdc/stdlib.d druntime/src/core/stdc/stdlib.d
--- druntime-orig/src/core/stdc/stdlib.d	2010-08-05 05:39:08.000000000 +0400
+++ druntime/src/core/stdc/stdlib.d	2010-10-26 19:26:03.996925001 +0400
@@ -92,3 +92,13 @@
 {
     void* alloca(size_t size); // non-standard
 }
+else version( LDC )
+{
+    pragma(alloca)
+        void* alloca(size_t size);
+}
+else version( GNU )
+{
+    private import gcc.builtins;
+    alias gcc.builtins.__builtin_alloca alloca;
+}
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/gc/gcbits.d druntime/src/gc/gcbits.d
--- druntime-orig/src/gc/gcbits.d	2010-08-08 04:10:24.000000000 +0400
+++ druntime/src/gc/gcbits.d	2010-10-01 20:49:51.268892001 +0400
@@ -26,6 +26,10 @@
 {
     version = bitops;
 }
+else version (LDC)
+{
+	version = bitops;
+}
 else version (GNU)
 {
     // use the unoptimized version
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/gc/gcx.d druntime/src/gc/gcx.d
--- druntime-orig/src/gc/gcx.d	2010-08-27 01:23:26.000000000 +0400
+++ druntime/src/gc/gcx.d	2010-10-07 22:27:41.879253001 +0400
@@ -1464,7 +1464,8 @@
 
 
     void initialize()
-    {   int dummy;
+    {
+        int dummy;
 
         (cast(byte*)&this)[0 .. Gcx.sizeof] = 0;
         stackBottom = cast(char*)&dummy;
@@ -2200,7 +2201,7 @@
                 if ((cast(size_t)p & ~(PAGESIZE-1)) == pcache)
                     continue;
 
-		auto pool = findPool(p);
+                auto pool = findPool(p);
                 if (pool)
                 {
                     size_t offset = cast(size_t)(p - pool.baseAddr);
@@ -2270,80 +2271,129 @@
             __builtin_unwind_init();
             sp = & sp;
         }
+        else version(LDC)
+        {
+            version(X86)
+            {
+                uint eax,ecx,edx,ebx,ebp,esi,edi;
+                asm
+                {
+                    mov eax[EBP], EAX      ;
+                    mov ecx[EBP], ECX      ;
+                    mov edx[EBP], EDX      ;
+                    mov ebx[EBP], EBX      ;
+                    mov ebp[EBP], EBP      ;
+                    mov esi[EBP], ESI      ;
+                    mov edi[EBP], EDI      ;
+                    mov  sp[EBP], ESP      ;
+                }
+            }
+            else version (X86_64)
+            {
+                ulong rax,rbx,rcx,rdx,rbp,rsi,rdi,r8,r9,r10,r11,r12,r13,r14,r15;
+                asm
+                {
+                    movq rax[RBP], RAX      ;
+                    movq rbx[RBP], RBX      ;
+                    movq rcx[RBP], RCX      ;
+                    movq rdx[RBP], RDX      ;
+                    movq rbp[RBP], RBP      ;
+                    movq rsi[RBP], RSI      ;
+                    movq rdi[RBP], RDI      ;
+                    movq r8 [RBP], R8       ; 
+                    movq r9 [RBP], R9       ; 
+                    movq r10[RBP], R10      ;
+                    movq r11[RBP], R11      ;
+                    movq r12[RBP], R12      ;
+                    movq r13[RBP], R13      ;
+                    movq r14[RBP], R14      ;
+                    movq r15[RBP], R15      ;
+                    movq  sp[RBP], RSP      ;
+                }
+            }
+            else
+            {
+                static assert( false, "Architecture not supported." );
+            }
+        }
         else version( D_InlineAsm_X86 )
         {
-	    asm
-	    {
-		pushad              ;
-		mov sp[EBP],ESP     ;
-	    }
+            asm
+            {
+            pushad              ;
+            mov sp[EBP],ESP     ;
+            }
+        }
+        else version ( D_InlineAsm_X86_64 )
+        {
+            asm
+            {
+            push RAX ;
+            push RBX ;
+            push RCX ;
+            push RDX ;
+            push RSI ;
+            push RDI ;
+            push RBP ;
+            push R8  ;
+            push R9  ;
+            push R10  ;
+            push R11  ;
+            push R12  ;
+            push R13  ;
+            push R14  ;
+            push R15  ;
+            push EAX ;   // 16 byte align the stack
+            }
+        }
+        else
+        {
+            static assert( false, "Architecture not supported." );
         }
-	else version ( D_InlineAsm_X86_64 )
-	{
-	    asm
-	    {
-		push RAX ;
-		push RBX ;
-		push RCX ;
-		push RDX ;
-		push RSI ;
-		push RDI ;
-		push RBP ;
-		push R8  ;
-		push R9  ;
-		push R10  ;
-		push R11  ;
-		push R12  ;
-		push R13  ;
-		push R14  ;
-		push R15  ;
-		push EAX ;   // 16 byte align the stack
-	    }
-	}
-	else
-	{
-	    static assert( false, "Architecture not supported." );
-	}
 
         result = fullcollect(sp);
 
-	version( GNU )
-	{
-	    // registers will be popped automatically
-	}
-	else version( D_InlineAsm_X86 )
-	{
-	    asm
-	    {
-		popad;
-	    }
-	}
-	else version ( D_InlineAsm_X86_64 )
-	{
-	    asm
-	    {
-		pop EAX ;   // 16 byte align the stack
-		pop R15  ;
-		pop R14  ;
-		pop R13  ;
-		pop R12  ;
-		pop R11  ;
-		pop R10  ;
-		pop R9  ;
-		pop R8  ;
-		pop RBP ;
-		pop RDI ;
-		pop RSI ;
-		pop RDX ;
-		pop RCX ;
-		pop RBX ;
-		pop RAX ;
-	    }
-	}
-	else
-	{
-	    static assert( false, "Architecture not supported." );
-	}
+        version( GNU )
+        {
+            // registers will be popped automatically
+        }
+        else version(LDC)
+        {
+            // nothing to do
+        }
+        else version( D_InlineAsm_X86 )
+        {
+            asm
+            {
+            popad;
+            }
+        }
+        else version ( D_InlineAsm_X86_64 )
+        {
+            asm
+            {
+            pop EAX ;   // 16 byte align the stack
+            pop R15  ;
+            pop R14  ;
+            pop R13  ;
+            pop R12  ;
+            pop R11  ;
+            pop R10  ;
+            pop R9  ;
+            pop R8  ;
+            pop RBP ;
+            pop RDI ;
+            pop RSI ;
+            pop RDX ;
+            pop RCX ;
+            pop RBX ;
+            pop RAX ;
+            }
+        }
+        else
+        {
+            static assert( false, "Architecture not supported." );
+        }
         return result;
     }
 
@@ -2357,7 +2407,7 @@
         Pool*  pool;
 
         debug(COLLECT_PRINTF) printf("Gcx.fullcollect()\n");
-	//printf("\tpool address range = %p .. %p\n", minAddr, maxAddr);
+        //printf("\tpool address range = %p .. %p\n", minAddr, maxAddr);
 
         thread_suspendAll();
 
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/object_.d druntime/src/object_.d
--- druntime-orig/src/object_.d	2010-10-26 18:47:41.840925001 +0400
+++ druntime/src/object_.d	2010-10-26 19:27:09.224925000 +0400
@@ -1073,7 +1073,7 @@
 
 abstract class MemberInfo
 {
-    string name();
+    string name() { return ""; }; // LDC: FIXME:
 }
 
 class MemberInfo_field : MemberInfo
@@ -1663,7 +1663,6 @@
     {
         int len = 0;
         ModuleReference *mr;
-
         for (mr = _Dmodule_ref; mr; mr = mr.next)
             len++;
         _moduleinfo_array = new ModuleInfo*[len];
@@ -2025,7 +2024,6 @@
         _d_monitor_create(h);
         m = getMonitor(h);
     }
-
     IMonitor i = m.impl;
 
     if (i is null)
@@ -2124,7 +2122,7 @@
     size_t _aaLen(void* p);
     void* _aaGet(void** pp, TypeInfo keyti, size_t valuesize, ...);
     void* _aaGetRvalue(void* p, TypeInfo keyti, size_t valuesize, ...);
-    void* _aaIn(void* p, TypeInfo keyti);
+    void* _aaIn(void* p, TypeInfo keyti, ...);
     void _aaDel(void* p, TypeInfo keyti, ...);
     void[] _aaValues(void* p, size_t keysize, size_t valuesize);
     void[] _aaKeys(void* p, size_t keysize, size_t valuesize);
@@ -2169,7 +2167,7 @@
         return *cast(Key[]*) &a;
     }
 
-    int opApply(scope int delegate(ref Key, ref Value) dg)
+    int opApply(scope int delegate(ref Key, ref const Value) dg)
     {
         return _aaApply2(p, aligntsize(Key.sizeof), cast(_dg2_t)dg);
     }
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/rt/aaA.d druntime/src/rt/aaA.d
--- druntime-orig/src/rt/aaA.d	2010-08-05 05:39:06.000000000 +0400
+++ druntime/src/rt/aaA.d	2010-10-29 10:48:36.165035001 +0400
@@ -204,7 +204,7 @@
  * Add entry for key if it is not already there.
  */
 
-void* _aaGet(AA* aa, TypeInfo keyti, size_t valuesize, ...)
+void* _aaGet(AA* aa, TypeInfo keyti, size_t valuesize, void *pkey)
 in
 {
     assert(aa);
@@ -218,7 +218,6 @@
 }
 body
 {
-    auto pkey = cast(void *)(&valuesize + 1);
     size_t i;
     aaA *e;
     //printf("keyti = %p\n", keyti);
@@ -274,13 +273,12 @@
  * Returns null if it is not already there.
  */
 
-void* _aaGetRvalue(AA aa, TypeInfo keyti, size_t valuesize, ...)
+void* _aaGetRvalue(AA aa, TypeInfo keyti, size_t valuesize, void *pkey)
 {
     //printf("_aaGetRvalue(valuesize = %u)\n", valuesize);
     if (!aa.a)
         return null;
 
-    auto pkey = cast(void *)(&valuesize + 1);
     auto keysize = aligntsize(keyti.tsize());
     auto len = aa.a.b.length;
 
@@ -312,7 +310,7 @@
  *      !=null  in aa, return pointer to value
  */
 
-void* _aaIn(AA aa, TypeInfo keyti, ...)
+void* _aaIn(AA aa, TypeInfo keyti, void *pkey)
 in
 {
 }
@@ -324,8 +322,6 @@
 {
     if (aa.a)
     {
-        auto pkey = cast(void *)(&keyti + 1);
-
         //printf("_aaIn(), .length = %d, .ptr = %x\n", aa.a.length, cast(uint)aa.a.ptr);
         auto len = aa.a.b.length;
 
@@ -357,9 +353,8 @@
  * If key is not in aa[], do nothing.
  */
 
-void _aaDel(AA aa, TypeInfo keyti, ...)
+void _aaDel(AA aa, TypeInfo keyti, void *pkey)
 {
-    auto pkey = cast(void *)(&keyti + 1);
     aaA *e;
 
     if (aa.a && aa.a.b.length)
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/rt/adi.d druntime/src/rt/adi.d
--- druntime-orig/src/rt/adi.d	2010-08-05 05:39:06.000000000 +0400
+++ druntime/src/rt/adi.d	2010-10-29 11:49:52.065035002 +0400
@@ -35,6 +35,8 @@
     extern (C) void  gc_free( void* p );
 }
 
+version (DMD) version (X86)
+    version = DMD_X86;
 
 struct Array
 {
@@ -48,7 +50,7 @@
  * reversed.
  */
 
-extern (C) long _adReverseChar(char[] a)
+extern (C) char[] _adReverseChar(char[] a)
 {
     if (a.length > 1)
     {
@@ -108,7 +110,7 @@
             hi = hi - 1 + (stridehi - stridelo);
         }
     }
-    return *cast(long*)(&a);
+    return a;
 }
 
 unittest
@@ -143,7 +145,7 @@
  * reversed.
  */
 
-extern (C) long _adReverseWchar(wchar[] a)
+extern (C) wchar[] _adReverseWchar(wchar[] a)
 {
     if (a.length > 1)
     {
@@ -201,7 +203,7 @@
             hi = hi - 1 + (stridehi - stridelo);
         }
     }
-    return *cast(long*)(&a);
+    return a;
 }
 
 unittest
@@ -225,10 +227,10 @@
  * Support for array.reverse property.
  */
 
-extern (C) long _adReverse(Array a, size_t szelem)
+extern (C) void[] _adReverse(void[] a, size_t szelem)
 out (result)
 {
-    assert(result is *cast(long*)(&a));
+    assert(result.ptr is a.ptr);
 }
 body
 {
@@ -267,7 +269,7 @@
                 //gc_free(tmp);
         }
     }
-    return *cast(long*)(&a);
+    return a;
 }
 
 unittest
@@ -311,7 +313,7 @@
  * Sort array of chars.
  */
 
-extern (C) long _adSortChar(char[] a)
+extern (C) char[] _adSortChar(char[] a)
 {
     if (a.length > 1)
     {
@@ -326,14 +328,14 @@
         }
         delete da;
     }
-    return *cast(long*)(&a);
+    return a;
 }
 
 /**********************************************
  * Sort array of wchars.
  */
 
-extern (C) long _adSortWchar(wchar[] a)
+extern (C) wchar[] _adSortWchar(wchar[] a)
 {
     if (a.length > 1)
     {
@@ -348,7 +350,7 @@
         }
         delete da;
     }
-    return *cast(long*)(&a);
+    return a;
 }
 
 /***************************************
@@ -358,7 +360,7 @@
  *      0       not equal
  */
 
-extern (C) int _adEq(Array a1, Array a2, TypeInfo ti)
+extern (C) int _adEq(void[] a1, void[] a2, TypeInfo ti)
 {
     debug(adi) printf("_adEq(a1.length = %d, a2.length = %d)\n", a1.length, a2.length);
     if (a1.length != a2.length)
@@ -379,7 +381,7 @@
     return 1; // equal
 }
 
-extern (C) int _adEq2(Array a1, Array a2, TypeInfo ti)
+extern (C) int _adEq2(void[] a1, void[] a2, TypeInfo ti)
 {
     debug(adi) printf("_adEq2(a1.length = %d, a2.length = %d)\n", a1.length, a2.length);
     if (a1.length != a2.length)
@@ -405,7 +407,7 @@
  * Support for array compare test.
  */
 
-extern (C) int _adCmp(Array a1, Array a2, TypeInfo ti)
+extern (C) int _adCmp(void[] a1, void[] a2, TypeInfo ti)
 {
     debug(adi) printf("adCmp()\n");
     auto len = a1.length;
@@ -435,7 +437,7 @@
     return (a1.length > a2.length) ? 1 : -1;
 }
 
-extern (C) int _adCmp2(Array a1, Array a2, TypeInfo ti)
+extern (C) int _adCmp2(void[] a1, void[] a2, TypeInfo ti)
 {
     debug(adi) printf("_adCmp2(a1.length = %d, a2.length = %d)\n", a1.length, a2.length);
     return ti.compare(&a1, &a2);
@@ -461,9 +463,9 @@
  * Support for array compare test.
  */
 
-extern (C) int _adCmpChar(Array a1, Array a2)
+extern (C) int _adCmpChar(void[] a1, void[] a2)
 {
-  version (X86)
+  version (DMD_X86)
   {
     asm
     {   naked                   ;
@@ -569,8 +571,8 @@
 
         ret                     ;
     }
-  }
-  else
+  } 
+  else 
   {
     int len;
     int c;
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/rt/alloca.d druntime/src/rt/alloca.d
--- druntime-orig/src/rt/alloca.d	2010-08-05 05:39:06.000000000 +0400
+++ druntime/src/rt/alloca.d	2010-10-08 22:31:50.989547000 +0400
@@ -12,6 +12,9 @@
  */
 module rt.alloca;
 
+version (DMD)
+{
+
 /+
 #if DOS386
 extern size_t _x386_break;
@@ -133,3 +136,5 @@
         ret                     ;
     }
 }
+
+}
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/rt/lifetime.d druntime/src/rt/lifetime.d
--- druntime-orig/src/rt/lifetime.d	2010-08-05 05:39:06.000000000 +0400
+++ druntime/src/rt/lifetime.d	2010-10-29 10:40:39.533035001 +0400
@@ -92,6 +92,18 @@
     return gc_malloc(sz);
 }
 
+version (LDC)
+{
+
+/**
+ * for allocating a single POD value
+ */
+extern (C) void* _d_allocmemoryT(TypeInfo ti)
+{
+    return gc_malloc(ti.tsize(), !(ti.flags() & 1) ? BlkAttr.NO_SCAN : 0);
+}
+
+} // version (LDC)
 
 /**
  *
@@ -670,7 +682,7 @@
  * ti is the type of the resulting array, or pointer to element.
  * (For when the array is initialized to 0)
  */
-extern (C) ulong _d_newarrayT(TypeInfo ti, size_t length)
+extern (C) void[] _d_newarrayT(TypeInfo ti, size_t length)
 {
     ulong result;
     auto size = ti.next.tsize();                // array element size
@@ -702,7 +714,7 @@
         __setArrayAllocLength(info, size, isshared);
         result = cast(ulong)length + (cast(ulong)cast(size_t)arrstart << 32);
     }
-    return result;
+    return *cast(void[]*)&result;
 
 Loverflow:
     onOutOfMemoryError();
@@ -711,7 +723,7 @@
 /**
  * For when the array has a non-zero initializer.
  */
-extern (C) ulong _d_newarrayiT(TypeInfo ti, size_t length)
+extern (C) void[] _d_newarrayiT(TypeInfo ti, size_t length)
 {
     ulong result;
     auto size = ti.next.tsize();                // array element size
@@ -764,7 +776,7 @@
         __setArrayAllocLength(info, size, isshared);
         result = cast(ulong)length + (cast(ulong)cast(uint)arrstart << 32);
     }
-    return result;
+    return *cast(void[]*)&result;
 
 Loverflow:
     onOutOfMemoryError();
@@ -773,7 +785,7 @@
 /**
  *
  */
-extern (C) ulong _d_newarraymT(TypeInfo ti, int ndims, ...)
+extern (C) void[] _d_newarraymT(TypeInfo ti, int ndims, ...)
 {
     ulong result;
 
@@ -823,14 +835,14 @@
         }
         va_end(q);
     }
-    return result;
+    return *cast(void[]*)&result;
 }
 
 
 /**
  *
  */
-extern (C) ulong _d_newarraymiT(TypeInfo ti, int ndims, ...)
+extern (C) void[] _d_newarraymiT(TypeInfo ti, int ndims, ...)
 {
     ulong result;
 
@@ -881,7 +893,7 @@
         }
         va_end(q);
     }
-    return result;
+    return *cast(void[]*)&result;
 }
 
 
@@ -1381,7 +1393,7 @@
  * Append y[] to array pointed to by px
  * size is size of each array element.
  */
-extern (C) long _d_arrayappendT(TypeInfo ti, Array *px, byte[] y)
+extern (C) void[] _d_arrayappendT(TypeInfo ti, Array *px, byte[] y)
 {
     // only optimize array append where ti is not a shared type
     auto sizeelem = ti.next.tsize();            // array element size
@@ -1468,7 +1480,7 @@
   L1:
     px.length = newlength;
     memcpy(px.data + length * sizeelem, y.ptr, y.length * sizeelem);
-    return *cast(long*)px;
+    return *cast(void[]*)px;
 }
 
 
@@ -1552,21 +1564,36 @@
     return newcap;
 }
 
+version (LDC)
+{
+
+/**
+ * Appends a single element to an array.
+ */
+extern (C) void[] _d_arrayappendcT(TypeInfo ti, byte[] *x, byte *argp)
+{
+    return _d_arrayappendT(ti, cast(Array*)x, argp[0..1]);
+}
+
+}
+else
+{
 
 /**
  *
  */
-extern (C) long _d_arrayappendcT(TypeInfo ti, Array *x, ...)
+extern (C) void[] _d_arrayappendcT(TypeInfo ti, Array *x, ...)
 {
     byte *argp = cast(byte*)(&ti + 2);
     return _d_arrayappendT(ti, x, argp[0..1]);
 }
 
+}
 
 /**
  * Append dchar to char[]
  */
-extern (C) long _d_arrayappendcd(ref char[] x, dchar c)
+extern (C) void[] _d_arrayappendcd(ref char[] x, dchar c)
 {
     // c could encode into from 1 to 4 characters
     char[4] buf = void;
@@ -1612,7 +1639,7 @@
 /**
  * Append dchar to wchar[]
  */
-extern (C) long _d_arrayappendwd(ref wchar[] x, dchar c)
+extern (C) void[] _d_arrayappendwd(ref wchar[] x, dchar c)
 {
     // c could encode into from 1 to 2 w characters
     wchar[2] buf = void;
@@ -1798,7 +1825,7 @@
 /**
  *
  */
-extern (C) long _adDupT(TypeInfo ti, Array2 a)
+extern (C) void[] _adDupT(TypeInfo ti, void[] a)
 out (result)
 {
     auto sizeelem = ti.next.tsize();            // array element size
@@ -1819,7 +1846,7 @@
         r.length = a.length;
         memcpy(r.ptr, a.ptr, size);
     }
-    return *cast(long*)(&r);
+    return *cast(void[]*)(&r);
 }
 
 
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/rt/qsort.d druntime/src/rt/qsort.d
--- druntime-orig/src/rt/qsort.d	2010-08-05 05:39:06.000000000 +0400
+++ druntime/src/rt/qsort.d	2010-10-07 13:59:06.815253002 +0400
@@ -44,7 +44,7 @@
 structures.  The default value is optimized for a high cost for compares. */
 
 
-extern (C) long _adSort(Array a, TypeInfo ti)
+extern (C) void[] _adSort(void[] a, TypeInfo ti)
 {
   byte* base;
   byte*[40] stack;              // stack
@@ -124,7 +124,7 @@
       limit = sp[1];
     }
     else                                // else stack empty, all done
-      return *cast(long*)(&a);
+      return a;
   }
   assert(0);
 }
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/rt/qsort2.d druntime/src/rt/qsort2.d
--- druntime-orig/src/rt/qsort2.d	2010-08-05 05:39:06.000000000 +0400
+++ druntime/src/rt/qsort2.d	2010-10-07 14:01:41.359253001 +0400
@@ -31,14 +31,14 @@
     return tiglobal.compare(p1, p2);
 }
 
-extern (C) long _adSort(Array a, TypeInfo ti)
+extern (C) void[] _adSort(void[] a, TypeInfo ti)
 {
     synchronized
     {
         tiglobal = ti;
         qsort(a.ptr, a.length, cast(size_t)ti.tsize(), &cmp);
     }
-    return *cast(long*)(&a);
+    return a;
 }
 
 
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- druntime-orig/src/rt/trace.d druntime/src/rt/trace.d
--- druntime-orig/src/rt/trace.d	2010-08-07 09:46:06.000000000 +0400
+++ druntime/src/rt/trace.d	2010-10-01 21:01:58.444892002 +0400
@@ -855,7 +855,7 @@
   version (OSX)
   { // 16 byte align stack
     asm
-    {   naked   ;
+    {
         pushad  ;
         sub     ESP,12  ;
     }
@@ -870,7 +870,7 @@
   else
   {
     asm
-    {   naked   ;
+    {
         pushad  ;
     }
     trace_epi();
