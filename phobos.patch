diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- phobos-orig/std/conv.d phobos/std/conv.d
--- phobos-orig/std/conv.d	2010-12-20 23:02:36.000000000 +0300
+++ phobos/std/conv.d	2011-01-08 12:48:19.925953001 +0300
@@ -3263,6 +3263,11 @@
 T toImpl(T, S)(S d) if (is(Unqual!S == double) && isSomeString!(T))
 {
     //alias Unqual!(ElementType!T) Char;
+    version(LDC) // FIXME: workarond for case when this function returns "-nan" 
+    {
+        if (isnan(d))
+            return "nan";
+    }
     char[20] buffer;
     int len = sprintf(buffer.ptr, "%g", d);
     return to!T(buffer[0 .. len].dup);
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- phobos-orig/std/internal/math/biguintx86.d phobos/std/internal/math/biguintx86.d
--- phobos-orig/std/internal/math/biguintx86.d	2010-12-20 23:02:36.000000000 +0300
+++ phobos/std/internal/math/biguintx86.d	2011-01-05 15:15:30.000000000 +0300
@@ -734,7 +734,10 @@
     // EDI = dest
     // ESI = src
 
-    enum string OP = (op=='+')? "add" : "sub";
+    version(LDC) { 
+    } else {
+        enum string OP = (op=='+')? "add" : "sub";
+    }
     version(D_PIC) {
         enum { zero = 0 }
     } else {
@@ -768,7 +771,10 @@
         jnz L_enter_odd;
 }
                 // Main loop, with entry point for even length
-mixin(asmMulAdd_innerloop(OP, "ESP+LASTPARAM"));
+version(LDC)
+    mixin(asmMulAdd_innerloop((op=='+')? "add" : "sub", "ESP+LASTPARAM"));
+else
+    mixin(asmMulAdd_innerloop(OP, "ESP+LASTPARAM"));
 asm {
         mov EAX, EBP; // get final carry
         pop EBP;
@@ -778,6 +784,9 @@
         ret 5*4;
 }
 L_enter_odd:
+version(LDC)
+    mixin(asmMulAdd_enter_odd((op=='+')? "add" : "sub", "ESP+LASTPARAM"));
+else
     mixin(asmMulAdd_enter_odd(OP, "ESP+LASTPARAM"));
 }
 
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- phobos-orig/std/math.d phobos/std/math.d
--- phobos-orig/std/math.d	2011-01-05 16:04:59.087062853 +0300
+++ phobos/std/math.d	2011-01-08 12:53:21.049953002 +0300
@@ -64,7 +64,7 @@
 
 version(LDC) {
     import ldc.intrinsics;
-    version = INLINE_YL2X; 
+    //version = INLINE_YL2X; 
 }
 
 version(DigitalMars){
@@ -266,7 +266,7 @@
     assert(abs(71.6Li) == 71.6L);
     assert(abs(-56) == 56);
     assert(abs(2321312L)  == 2321312L);
-    assert(abs(-1+1i) == sqrt(2.0));
+    assert(abs(-1+1i) == sqrt(2.0L));
 }
 
 /***********************************
@@ -308,8 +308,22 @@
  *      Results are undefined if |x| >= $(POWER 2,64).
  */
 
+version(LDC)
+{
+
+@safe pure nothrow real cos(real x)
+{ 
+    return llvm_cos(x); 
+}
+
+{
+else
+{
+
 real cos(real x) @safe pure nothrow;       /* intrinsic */
 
+}
+
 /***********************************
  * Returns sine of x. x is in radians.
  *
@@ -322,9 +336,22 @@
  * Bugs:
  *      Results are undefined if |x| >= $(POWER 2,64).
  */
+version(LDC)
+{
+
+@safe pure nothrow real sin(real x)
+{ 
+    return llvm_sin(x); 
+}
+
+{
+else
+{
 
 real sin(real x) @safe pure nothrow;       /* intrinsic */
 
+}
+
 
 /***********************************
  *  sine, complex and imaginary
@@ -390,7 +417,9 @@
 
 real tan(real x) @trusted pure nothrow 
 {
-    version(D_InlineAsm_X86) {
+    version(LDC) {
+        return core.stdc.math.tanl(x);
+    } else version(D_InlineAsm_X86) {
     asm
     {
         fld     x[EBP]                  ; // load theta
@@ -806,8 +835,22 @@
  * greater than long.max, the result is
  * indeterminate.
  */
+version(LDC)
+{
+
+@trusted pure nothrow long rndtol(real x)
+{
+	return core.stdc.math.llroundl(x);
+}
+
+}
+else
+{
+
 long rndtol(real x) @safe pure nothrow;    /* intrinsic */
 
+}
+
 
 /*****************************************
  * Returns x rounded to a long value using the FE_TONEAREST rounding mode.
@@ -828,6 +871,20 @@
  *      )
  */
 
+version(LDC) 
+{
+
+@safe pure nothrow
+{
+    float sqrt(float x) { return llvm_sqrt(x); }
+    double sqrt(double x)  { return llvm_sqrt(x); }
+    real sqrt(real x) { return llvm_sqrt(x); }
+}
+
+}
+else
+{
+
 @safe pure nothrow
 {
     float sqrt(float x);    /* intrinsic */
@@ -835,6 +892,8 @@
     real sqrt(real x);      /* intrinsic */ /// ditto
 }
 
+}
+
 @trusted pure nothrow {  // Should be @safe.  See bugs 4628, 4630.
     // Create explicit overloads for integer sqrts.  No ddoc for these because
     // hopefully a more elegant solution will eventually be found, so we don't
@@ -1421,9 +1480,22 @@
  * Compute n * 2$(SUP exp)
  * References: frexp
  */
+version(LDC)
+{
+
+pure nothrow real ldexp(real n, int exp)
+{
+    return core.stdc.math.ldexpl(n, exp);
+}
+
+}
+else
+{
 
 real ldexp(real n, int exp) @safe pure nothrow;    /* intrinsic */
 
+}
+
 unittest {
     assert(ldexp(1, -16384) == 0x1p-16384L);
     assert(ldexp(1, -16382) == 0x1p-16382L);
@@ -1446,7 +1518,7 @@
  *    )
  */
 
-real log(real x) @safe pure nothrow 
+real log(real x) @trusted pure nothrow 
 {
     version (INLINE_YL2X)
         return yl2x(x, LN2);
@@ -1470,7 +1542,7 @@
  *      )
  */
 
-real log10(real x) @safe pure nothrow
+real log10(real x) @trusted pure nothrow
 {
     version (INLINE_YL2X)
         return yl2x(x, LOG2);
@@ -1499,7 +1571,7 @@
  *  )
  */
 
-real log1p(real x) @safe pure nothrow
+real log1p(real x) @trusted pure nothrow
 {
     version(INLINE_YL2X)
     {
@@ -1524,7 +1596,7 @@
  *  $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no) )
  *  )
  */
-real log2(real x) @safe pure nothrow
+real log2(real x) @trusted pure nothrow
 {
     version (INLINE_YL2X)
         return yl2x(x, 1);
@@ -1617,7 +1689,24 @@
  *      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) )
  *      )
  */
-real fabs(real x) @safe pure nothrow;      /* intrinsic */
+version(LDC) {
+    @trusted pure nothrow real fabs(real x) 
+    {
+        version(D_InlineAsm_X86)
+        {
+            asm {
+                fld x;
+                fabs;
+            }
+        }
+        else
+        {
+            return fabsl(x);
+        }
+    }
+} else {
+    real fabs(real x) @safe pure nothrow;      /* intrinsic */
+}
 
 
 /***********************************************************************
@@ -3017,9 +3106,15 @@
     assert(pow(x,eight) == (x * x) * (x * x) * (x * x) * (x * x));
 
     assert(pow(x, neg1) == 1 / x);
-    assert(pow(xd, neg2) == 1 / (x * x));
+    version(LDC) // FIXME:
+        assert(pow(xd, neg2) == 1 / (xd * xd));
+    else
+        assert(pow(xd, neg2) == 1 / (x * x));
     assert(pow(x, neg3) == 1 / (x * x * x));
-    assert(pow(xf, neg8) == 1 / ((x * x) * (x * x) * (x * x) * (x * x)));
+    version(LDC)
+        assert(pow(xf, neg8) == 1 / ((xf * xf) * (xf * xf) * (xf * xf) * (xf * xf)));
+    else
+        assert(pow(xf, neg8) == 1 / ((x * x) * (x * x) * (x * x) * (x * x)));
 }
 
 /** Compute the value of an integer x, raised to the power of a positive
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- phobos-orig/std/openrj.d phobos/std/openrj.d
--- phobos-orig/std/openrj.d	2009-09-03 12:01:40.000000000 +0400
+++ phobos/std/openrj.d	2011-01-05 15:15:30.000000000 +0300
@@ -620,11 +620,11 @@
     /**
      *
      */
-    int opApply(int delegate(inout Field field) dg)
+    int opApply(int delegate(ref Field field) dg)
     {
         int result  =   0;
 
-        foreach (inout field; m_fields)
+        foreach (ref Field field; m_fields)
         {
             result = dg(field);
 
@@ -1000,11 +1000,11 @@
     /**
      *
      */
-    int opApply(int delegate(inout Record record) dg)
+    int opApply(int delegate(ref Record record) dg)
     {
         int result  =   0;
 
-        foreach(inout Record record; m_records)
+        foreach(ref Record record; m_records)
         {
             result = dg(record);
 
@@ -1020,11 +1020,11 @@
     /**
      *
      */
-    int opApply(int delegate(inout Field field) dg)
+    int opApply(int delegate(ref Field field) dg)
     {
         int result  =   0;
 
-        foreach(inout Field field; m_fields)
+        foreach(ref Field field; m_fields)
         {
             result = dg(field);
 
diff -U 3 -H -d -r -N -x '*.mak' -x tk -x backend -x debug -x release -x '*_pch.h' -x Makefile -x '*.rej' -x '*~' -x '*.log' -x .svn -x '*pro.user' -x .directory -x cmake_install -x CMakeFiles -x .preprocessed.tmp -x 'Makefile.*' -x '*.orig' -- phobos-orig/std/outbuffer.d phobos/std/outbuffer.d
--- phobos-orig/std/outbuffer.d	2010-12-20 23:02:36.000000000 +0300
+++ phobos/std/outbuffer.d	2011-01-05 15:15:31.000000000 +0300
@@ -308,8 +308,15 @@
     void printf(string format, ...)
     {
         va_list ap;
-        ap = cast(va_list)&format;
-        ap += format.sizeof;
+        version(LDC) 
+        {
+            ap = _argptr;
+        }
+        else
+        {
+            ap = cast(va_list)&format;
+            ap += format.sizeof;
+        }
         vprintf(format, ap);
     }
 
