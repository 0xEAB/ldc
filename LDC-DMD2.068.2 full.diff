diff --git a/src/aggregate.h b/src/aggregate.h
index 299b59a..8bf0763 100644
--- a/src/aggregate.h
+++ b/src/aggregate.h
@@ -130,10 +130,12 @@ public:
     Prot prot();
 
     Type *handleType() { return type; } // 'this' type
+#if IN_DMD
 
     // Back end
     Symbol *stag;               // tag symbol for debug data
     Symbol *sinit;
+#endif
 
     AggregateDeclaration *isAggregateDeclaration() { return this; }
     void accept(Visitor *v) { v->visit(this); }
@@ -297,8 +299,10 @@ public:
 
     void addLocalClass(ClassDeclarations *);
 
+#if IN_DMD
     // Back end
     Symbol *vtblsym;
+#endif
 
     ClassDeclaration *isClassDeclaration() { return (ClassDeclaration *)this; }
     void accept(Visitor *v) { v->visit(this); }
diff --git a/src/arrayop.c b/src/arrayop.c
index 11a312b..2890243 100644
--- a/src/arrayop.c
+++ b/src/arrayop.c
@@ -34,7 +34,9 @@ Expression *buildArrayLoop(Expression *e, Parameters *fparams);
  * Hash table of array op functions already generated or known about.
  */
 
+#if IN_DMD
 AA *arrayfuncs;
+#endif
 
 /**************************************
  * Structure to contain information needed to insert an array op call
@@ -50,7 +52,6 @@ FuncDeclaration *buildArrayOp(Identifier *ident, BinExp *exp, Scope *sc, Loc loc
      *      loopbody;
      *  return p;
      */
-
     Parameter *p = (*fparams)[0];
     // foreach (i; 0 .. p.length)
     Statement *s1 = new ForeachRangeStatement(Loc(), TOKforeach,
@@ -209,7 +210,11 @@ Expression *arrayOp(BinExp *e, Scope *sc)
     char *name = buf.peekString();
     Identifier *ident = Identifier::idPool(name);
 
+#if IN_LLVM
+    FuncDeclaration **pFd = (FuncDeclaration **)dmd_aaGet(&sc->module->arrayfuncs, (void *)ident);
+#else    
     FuncDeclaration **pFd = (FuncDeclaration **)dmd_aaGet(&arrayfuncs, (void *)ident);
+#endif
     FuncDeclaration *fd = *pFd;
 
     if (!fd)
diff --git a/src/attrib.c b/src/attrib.c
index 137362c..e6f90d5 100644
--- a/src/attrib.c
+++ b/src/attrib.c
@@ -30,6 +30,9 @@
 #include "template.h"
 #include "utf.h"
 #include "mtype.h"
+#if IN_LLVM
+#include "../gen/pragma.h"
+#endif
 
 
 /********************************* AttribDeclaration ****************************/
@@ -853,6 +856,11 @@ void PragmaDeclaration::semantic(Scope *sc)
 {
     // Should be merged with PragmaStatement
 
+#if IN_LLVM
+    Pragma llvm_internal = LLVMnone;
+    std::string arg1str;
+#endif
+
     //printf("\tPragmaDeclaration::semantic '%s'\n",toChars());
     if (ident == Id::msg)
     {
@@ -1034,6 +1042,12 @@ void PragmaDeclaration::semantic(Scope *sc)
         }
 #endif
     }
+#if IN_LLVM
+    else if ((llvm_internal = DtoGetPragma(sc, this, arg1str)) != LLVMnone)
+    {
+        // nothing to do anymore
+    }
+#endif
     else if (global.params.ignoreUnsupportedPragmas)
     {
         if (global.params.verbose)
@@ -1046,7 +1060,11 @@ void PragmaDeclaration::semantic(Scope *sc)
                 for (size_t i = 0; i < args->dim; i++)
                 {
                     Expression *e = (*args)[i];
-
+#if IN_LLVM
+                    // ignore errors in ignored pragmas.
+                    global.gag++;
+                    unsigned errors_save = global.errors;
+#endif
                     sc = sc->startCTFE();
                     e = e->semantic(sc);
                     e = resolveProperties(sc, e);
@@ -1058,13 +1076,17 @@ void PragmaDeclaration::semantic(Scope *sc)
                     else
                         fprintf(global.stdmsg, ",");
                     fprintf(global.stdmsg, "%s", e->toChars());
+#if IN_LLVM
+                    // restore error state.
+                    global.gag--;
+                    global.errors = errors_save;
+#endif
                 }
                 if (args->dim)
                     fprintf(global.stdmsg, ")");
             }
             fprintf(global.stdmsg, "\n");
         }
-        goto Lnodecl;
     }
     else
         error("unrecognized pragma(%s)", ident->toChars());
@@ -1094,6 +1116,13 @@ Ldecl:
                         error("can only apply to a single declaration");
                 }
             }
+#if IN_LLVM
+            else
+            {
+                DtoCheckPragma(this, s, llvm_internal, arg1str);
+            }
+#endif
+
         }
 
         if (sc2 != sc)
diff --git a/src/builtin.c b/src/builtin.c
index 32f158e..9375f8d 100644
--- a/src/builtin.c
+++ b/src/builtin.c
@@ -26,6 +26,10 @@
 #include "module.h"
 #include "root/port.h"
 #include "tokens.h"
+#if IN_LLVM
+#include "template.h"
+#include "gen/pragma.h"
+#endif
 
 StringTable builtins;
 
@@ -81,6 +85,246 @@ Expression *eval_fabs(Loc loc, FuncDeclaration *fd, Expressions *arguments)
     return new RealExp(loc, fabsl(arg0->toReal()), arg0->type);
 }
 
+#if IN_LLVM
+
+static inline Type *getTypeOfOverloadedIntrinsic(FuncDeclaration *fd)
+{
+    // Depending on the state of the code generation we have to look at
+    // the template instance or the function declaration.
+    assert(fd->parent && "function declaration requires parent");
+    TemplateInstance* tinst = fd->parent->isTemplateInstance();
+    if (tinst)
+    {
+        // See DtoOverloadedIntrinsicName
+        assert(tinst->tdtypes.dim == 1);
+        return static_cast<Type*>(tinst->tdtypes.data[0]);
+    }
+    else
+    {
+        assert(fd->type->ty == Tfunction);
+        TypeFunction *tf = static_cast<TypeFunction *>(fd->type);
+        assert(tf->parameters->dim >= 1);
+        return tf->parameters->data[0]->type;
+    }
+}
+
+static inline int getBitsizeOfType(Loc loc, Type *type)
+{
+    switch (type->toBasetype()->ty)
+    {
+      case Tint64:
+      case Tuns64: return 64;
+      case Tint32:
+      case Tuns32: return 32;
+      case Tint16:
+      case Tuns16: return 16;
+      case Tint128:
+      case Tuns128:
+          error(loc, "cent/ucent not supported");
+          break;
+      default:
+          error(loc, "unsupported type");
+          break;
+    }
+    return 32; // in case of error
+}
+
+Expression *eval_llvmsin(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    return new RealExp(loc, sinl(arg0->toReal()), type);
+}
+
+Expression *eval_llvmcos(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    return new RealExp(loc, cosl(arg0->toReal()), type);
+}
+
+Expression *eval_llvmsqrt(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    return new RealExp(loc, sqrtl(arg0->toReal()), type);
+}
+
+Expression *eval_llvmlog(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    return new RealExp(loc, logl(arg0->toReal()), type);
+}
+
+Expression *eval_llvmfabs(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    return new RealExp(loc, fabsl(arg0->toReal()), type);
+}
+
+Expression *eval_llvmminnum(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    Expression *arg1 = (*arguments)[1];
+    assert(arg1->op == TOKfloat64);
+    return new RealExp(loc, fminl(arg0->toReal(), arg1->toReal()), type);
+}
+
+Expression *eval_llvmmaxnum(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    Expression *arg1 = (*arguments)[1];
+    assert(arg1->op == TOKfloat64);
+    return new RealExp(loc, fmaxl(arg0->toReal(), arg1->toReal()), type);
+}
+
+Expression *eval_llvmfloor(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    return new RealExp(loc, floor(arg0->toReal()), type);
+}
+
+Expression *eval_llvmceil(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    return new RealExp(loc, ceil(arg0->toReal()), type);
+}
+
+Expression *eval_llvmtrunc(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    return new RealExp(loc, trunc(arg0->toReal()), type);
+}
+
+Expression *eval_llvmround(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKfloat64);
+    return new RealExp(loc, round(arg0->toReal()), type);
+}
+
+Expression *eval_cttz(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKint64);
+    uinteger_t x = arg0->toInteger();
+
+    int n = getBitsizeOfType(loc, type);
+
+    if (x == 0)
+    {
+        if ((*arguments)[1]->toInteger())
+            error(loc, "llvm.cttz.i#(0) is undefined");
+    }
+    else
+    {
+        int c = n >> 1;
+        n -= 1;
+        const uinteger_t mask = (static_cast<uinteger_t>(1L) << n) 
+                                | (static_cast<uinteger_t>(1L) << n)-1;
+        do {
+            uinteger_t y = (x << c) & mask; if (y != 0) { n -= c; x = y; }
+            c = c >> 1;
+        } while (c != 0);
+    }
+
+    return new IntegerExp(loc, n, type);
+}
+
+Expression *eval_ctlz(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKint64);
+    uinteger_t x = arg0->toInteger();
+    if (x == 0 && (*arguments)[1]->toInteger())
+        error(loc, "llvm.ctlz.i#(0) is undefined");
+
+    int n = getBitsizeOfType(loc, type);
+    int c = n >> 1;
+    do {
+        uinteger_t y = x >> c; if (y != 0) { n -= c; x = y; }
+        c = c >> 1;
+    } while (c != 0);
+
+    return new IntegerExp(loc, n - x, type);
+}
+
+Expression *eval_bswap(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKint64);
+    uinteger_t n = arg0->toInteger();
+    #define BYTEMASK  0x00FF00FF00FF00FFLL
+    #define SHORTMASK 0x0000FFFF0000FFFFLL
+    #define INTMASK 0x00000000FFFFFFFFLL
+    switch (type->toBasetype()->ty)
+    {
+      case Tint64:
+      case Tuns64:
+          // swap high and low uints
+          n = ((n >> 32) & INTMASK) | ((n & INTMASK) << 32);
+      case Tint32:
+      case Tuns32:
+          // swap adjacent ushorts
+          n = ((n >> 16) & SHORTMASK) | ((n & SHORTMASK) << 16);
+      case Tint16:
+      case Tuns16:
+          // swap adjacent ubytes
+          n = ((n >> 8 ) & BYTEMASK)  | ((n & BYTEMASK) << 8 );
+          break;
+      case Tint128:
+      case Tuns128:
+          error(loc, "cent/ucent not supported");
+          break;
+      default:
+          error(loc, "unsupported type");
+          break;
+    }
+    return new IntegerExp(loc, n, type);
+}
+
+Expression *eval_ctpop(Loc loc, FuncDeclaration *fd, Expressions *arguments)
+{
+    // FIXME Does not work for cent/ucent
+    Type* type = getTypeOfOverloadedIntrinsic(fd);
+
+    Expression *arg0 = (*arguments)[0];
+    assert(arg0->op == TOKint64);
+    uinteger_t n = arg0->toInteger();
+    int cnt = 0;
+    while (n)
+    {
+        cnt += (n & 1);
+        n >>= 1;
+    }
+    return new IntegerExp(loc, cnt, type);
+}
+#else
+
 Expression *eval_bsf(Loc loc, FuncDeclaration *fd, Expressions *arguments)
 {
     Expression *arg0 = (*arguments)[0];
@@ -130,6 +374,7 @@ Expression *eval_bswap(Loc loc, FuncDeclaration *fd, Expressions *arguments)
         n = ((n >> 32) & INTMASK) | ((n & INTMASK) << 32);
     return new IntegerExp(loc, n, arg0->type);
 }
+#endif
 
 Expression *eval_popcnt(Loc loc, FuncDeclaration *fd, Expressions *arguments)
 {
@@ -173,7 +418,11 @@ Expression *eval_yl2xp1(Loc loc, FuncDeclaration *fd, Expressions *arguments)
 
 void builtin_init()
 {
+#if IN_LLVM
+    builtins._init(127); // Prime number like default value
+#else
     builtins._init(47);
+#endif
 
     // @safe @nogc pure nothrow real function(real)
     add_builtin("_D4core4math3sinFNaNbNiNfeZe", &eval_sin);
@@ -269,6 +518,112 @@ void builtin_init()
     // @safe @nogc pure nothrow long function(real)
     add_builtin("_D3std4math6rndtolFNaNbNiNfeZl", &eval_unimp);
 
+#if IN_LLVM
+    // intrinsic llvm.sin.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.sin.f32", &eval_llvmsin);
+    add_builtin("llvm.sin.f64", &eval_llvmsin);
+    add_builtin("llvm.sin.f80", &eval_llvmsin);
+    add_builtin("llvm.sin.f128", &eval_llvmsin);
+    add_builtin("llvm.sin.ppcf128", &eval_llvmsin);
+
+    // intrinsic llvm.cos.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.cos.f32", &eval_llvmcos);
+    add_builtin("llvm.cos.f64", &eval_llvmcos);
+    add_builtin("llvm.cos.f80", &eval_llvmcos);
+    add_builtin("llvm.cos.f128", &eval_llvmcos);
+    add_builtin("llvm.cos.ppcf128", &eval_llvmcos);
+
+    // intrinsic llvm.sqrt.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.sqrt.f32", &eval_llvmsqrt);
+    add_builtin("llvm.sqrt.f64", &eval_llvmsqrt);
+    add_builtin("llvm.sqrt.f80", &eval_llvmsqrt);
+    add_builtin("llvm.sqrt.f128", &eval_llvmsqrt);
+    add_builtin("llvm.sqrt.ppcf128", &eval_llvmsqrt);
+
+    // intrinsic llvm.log.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.log.f32", &eval_llvmlog);
+    add_builtin("llvm.log.f64", &eval_llvmlog);
+    add_builtin("llvm.log.f80", &eval_llvmlog);
+    add_builtin("llvm.log.f128", &eval_llvmlog);
+    add_builtin("llvm.log.ppcf128", &eval_llvmlog);
+
+    // intrinsic llvm.fabs.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.fabs.f32", &eval_llvmfabs);
+    add_builtin("llvm.fabs.f64", &eval_llvmfabs);
+    add_builtin("llvm.fabs.f80", &eval_llvmfabs);
+    add_builtin("llvm.fabs.f128", &eval_llvmfabs);
+    add_builtin("llvm.fabs.ppcf128", &eval_llvmfabs);
+
+    // intrinsic llvm.minnum.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.minnum.f32", &eval_llvmminnum);
+    add_builtin("llvm.minnum.f64", &eval_llvmminnum);
+    add_builtin("llvm.minnum.f80", &eval_llvmminnum);
+    add_builtin("llvm.minnum.f128", &eval_llvmminnum);
+    add_builtin("llvm.minnum.ppcf128", &eval_llvmminnum);
+
+    // intrinsic llvm.maxnum.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.maxnum.f32", &eval_llvmmaxnum);
+    add_builtin("llvm.maxnum.f64", &eval_llvmmaxnum);
+    add_builtin("llvm.maxnum.f80", &eval_llvmmaxnum);
+    add_builtin("llvm.maxnum.f128", &eval_llvmmaxnum);
+    add_builtin("llvm.maxnum.ppcf128", &eval_llvmmaxnum);
+
+    // intrinsic llvm.floor.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.floor.f32", &eval_llvmfloor);
+    add_builtin("llvm.floor.f64", &eval_llvmfloor);
+    add_builtin("llvm.floor.f80", &eval_llvmfloor);
+    add_builtin("llvm.floor.f128", &eval_llvmfloor);
+    add_builtin("llvm.floor.ppcf128", &eval_llvmfloor);
+
+    // intrinsic llvm.ceil.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.ceil.f32", &eval_llvmceil);
+    add_builtin("llvm.ceil.f64", &eval_llvmceil);
+    add_builtin("llvm.ceil.f80", &eval_llvmceil);
+    add_builtin("llvm.ceil.f128", &eval_llvmceil);
+    add_builtin("llvm.ceil.ppcf128", &eval_llvmceil);
+
+    // intrinsic llvm.trunc.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.trunc.f32", &eval_llvmtrunc);
+    add_builtin("llvm.trunc.f64", &eval_llvmtrunc);
+    add_builtin("llvm.trunc.f80", &eval_llvmtrunc);
+    add_builtin("llvm.trunc.f128", &eval_llvmtrunc);
+    add_builtin("llvm.trunc.ppcf128", &eval_llvmtrunc);
+
+    // intrinsic llvm.round.f32/f64/f80/f128/ppcf128
+    add_builtin("llvm.round.f32", &eval_llvmround);
+    add_builtin("llvm.round.f64", &eval_llvmround);
+    add_builtin("llvm.round.f80", &eval_llvmround);
+    add_builtin("llvm.round.f128", &eval_llvmround);
+    add_builtin("llvm.round.ppcf128", &eval_llvmround);
+
+    // intrinsic llvm.bswap.i16/i32/i64/i128
+    add_builtin("llvm.bswap.i16", &eval_bswap);
+    add_builtin("llvm.bswap.i32", &eval_bswap);
+    add_builtin("llvm.bswap.i64", &eval_bswap);
+    add_builtin("llvm.bswap.i128", &eval_bswap);
+
+    // intrinsic llvm.cttz.i8/i16/i32/i64/i128
+    add_builtin("llvm.cttz.i8", &eval_cttz);
+    add_builtin("llvm.cttz.i16", &eval_cttz);
+    add_builtin("llvm.cttz.i32", &eval_cttz);
+    add_builtin("llvm.cttz.i64", &eval_cttz);
+    add_builtin("llvm.cttz.i128", &eval_cttz);
+
+    // intrinsic llvm.ctlz.i8/i16/i32/i64/i128
+    add_builtin("llvm.ctlz.i8", &eval_ctlz);
+    add_builtin("llvm.ctlz.i16", &eval_ctlz);
+    add_builtin("llvm.ctlz.i32", &eval_ctlz);
+    add_builtin("llvm.ctlz.i64", &eval_ctlz);
+    add_builtin("llvm.ctlz.i128", &eval_ctlz);
+
+    // intrinsic llvm.ctpop.i8/i16/i32/i64/i128
+    add_builtin("llvm.ctpop.i8", &eval_ctpop);
+    add_builtin("llvm.ctpop.i16", &eval_ctpop);
+    add_builtin("llvm.ctpop.i32", &eval_ctpop);
+    add_builtin("llvm.ctpop.i64", &eval_ctpop);
+    add_builtin("llvm.ctpop.i128", &eval_ctpop);
+#else
+
     // @safe @nogc pure nothrow int function(uint)
     add_builtin("_D4core5bitop3bsfFNaNbNiNfkZi", &eval_bsf);
     add_builtin("_D4core5bitop3bsrFNaNbNiNfkZi", &eval_bsr);
@@ -289,6 +644,7 @@ void builtin_init()
     // @safe @nogc pure nothrow int function(ulong)
     if (global.params.is64bit)
         add_builtin("_D4core5bitop7_popcntFNaNbNiNfmZi", &eval_popcnt);
+#endif
 }
 
 /**********************************
diff --git a/src/class.c b/src/class.c
index 48187ce..34fe842 100644
--- a/src/class.c
+++ b/src/class.c
@@ -65,7 +65,9 @@ ClassDeclaration::ClassDeclaration(Loc loc, Identifier *id, BaseClasses *basecla
     staticCtor = NULL;
     staticDtor = NULL;
 
+#if IN_DMD
     vtblsym = NULL;
+#endif
     vclassinfo = NULL;
 
     if (id)
diff --git a/src/cond.c b/src/cond.c
index 4f8a4ad..fc24067 100644
--- a/src/cond.c
+++ b/src/cond.c
@@ -205,6 +205,9 @@ bool VersionCondition::isPredefined(const char *ident)
         "SPARC64",
         "S390",
         "S390X",
+#if IN_LLVM
+        "SystemZ",
+#endif
         "HPPA",
         "HPPA64",
         "SH",
@@ -216,6 +219,9 @@ bool VersionCondition::isPredefined(const char *ident)
         "BigEndian",
         "ELFv1",
         "ELFv2",
+#if IN_LLVM
+        "CRuntime_Bionic",
+#endif
         "CRuntime_Digitalmars",
         "CRuntime_Glibc",
         "CRuntime_Microsoft",
diff --git a/src/constfold.c b/src/constfold.c
index 2a0c81e..2068bd1 100644
--- a/src/constfold.c
+++ b/src/constfold.c
@@ -27,6 +27,10 @@
 #include "utf.h"
 #include "ctfe.h"
 
+#if IN_LLVM
+#include "gen/pragma.h"
+#endif
+
 #define LOG 0
 
 int RealEquals(real_t x1, real_t x2);
@@ -55,6 +59,16 @@ int isConst(Expression *e)
         case TOKnull:
             return 0;
         case TOKsymoff:
+#if IN_LLVM
+            // We don't statically know anything about the address of a weak symbol
+            // if there is no offset. With an offset, we can at least say that it is
+            // non-zero.
+            {
+                SymOffExp *soe = (SymOffExp*)e;
+                if (soe->var->llvmInternal == LLVMextern_weak && !soe->offset)
+                    return 0;
+            }
+#endif
             return 2;
         default:
             return 0;
@@ -1657,7 +1671,16 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)
             size_t len = (t->ty == tn->ty) ? 1 : utf_codeLength(sz, (dchar_t)v);
             void *s = mem.xmalloc((len + 1) * sz);
             if (t->ty == tn->ty)
+#if IN_LLVM
+#if __LITTLE_ENDIAN__
+                memcpy((unsigned char *)s, &v, sz);
+#else
+                memcpy((unsigned char *)s,
+                       (unsigned char *)&v + (sizeof(dinteger_t) - sz), sz);
+#endif
+#else
                 memcpy(s, &v, sz);
+#endif
             else
                 utf_encode(sz, s, (dchar_t)v);
 
@@ -1799,7 +1822,16 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)
         void *s = mem.xmalloc((len + 1) * sz);
         memcpy(s, es1->string, es1->len * sz);
         if (homoConcat)
+#if IN_LLVM
+#if __LITTLE_ENDIAN__
+             memcpy((unsigned char *)s + (sz * es1->len), &v, sz);
+#else
+             memcpy((unsigned char *)s + (sz * es1->len),
+                    (unsigned char *)&v + (sizeof(dinteger_t) - sz), sz);
+#endif
+#else
              memcpy((char *)s + (sz * es1->len), &v, sz);
+#endif
         else
              utf_encode(sz, (char *)s + (sz * es1->len), (dchar_t)v);
 
@@ -1823,7 +1855,16 @@ UnionExp Cat(Type *type, Expression *e1, Expression *e2)
         dinteger_t v = e1->toInteger();
 
         void *s = mem.xmalloc((len + 1) * sz);
+#if IN_LLVM
+#if __LITTLE_ENDIAN__
+        memcpy((unsigned char *)s, &v, sz);
+#else
+        memcpy((unsigned char *)s,
+               (unsigned char *)&v + (sizeof(dinteger_t) - sz), sz);
+#endif
+#else
         memcpy((char *)s, &v, sz);
+#endif
         memcpy((char *)s + sz, es2->string, es2->len * sz);
 
         // Add terminating 0
diff --git a/src/cppmangle.c b/src/cppmangle.c
index de0dd7b..44cfd24 100644
--- a/src/cppmangle.c
+++ b/src/cppmangle.c
@@ -38,7 +38,9 @@
  * so nothing would be compatible anyway.
  */
 
-#if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_OPENBSD || TARGET_SOLARIS
+#if !IN_LLVM
+//#if TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_OPENBSD || TARGET_SOLARIS
+#endif
 
 /*
  * Follows Itanium C++ ABI 1.86
@@ -176,7 +178,11 @@ class CppMangleVisitor : public Visitor
                     else
                     {
                         s->error("Internal Compiler Error: C++ %s template value parameter is not supported", tv->valType->toChars());
+#if IN_LLVM
+                        fatal();
+#else
                         assert(0);
+#endif
                     }
                 }
                 else if (!tp || tp->isTemplateTypeParameter())
@@ -192,7 +198,11 @@ class CppMangleVisitor : public Visitor
                     if (!d && !e)
                     {
                         s->error("Internal Compiler Error: %s is unsupported parameter for C++ template: (%s)", o->toChars());
+#if IN_LLVM
+                        fatal();
+#else
                         assert(0);
+#endif
                     }
                     if (d && d->isFuncDeclaration())
                     {
@@ -220,14 +230,22 @@ class CppMangleVisitor : public Visitor
                     else
                     {
                         s->error("Internal Compiler Error: %s is unsupported parameter for C++ template", o->toChars());
+#if IN_LLVM
+                        fatal();
+#else
                         assert(0);
+#endif
                     }
 
                 }
                 else
                 {
                     s->error("Internal Compiler Error: C++ templates support only integral value, type parameters, alias templates and alias function parameters");
+#if IN_LLVM
+                    fatal();
+#else
                     assert(0);
+#endif
                 }
             }
             if (is_var_arg)
@@ -400,13 +418,21 @@ class CppMangleVisitor : public Visitor
         if (!(d->storage_class & (STCextern | STCgshared)))
         {
             d->error("Internal Compiler Error: C++ static non- __gshared non-extern variables not supported");
+#if IN_LLVM
+            fatal();
+#else
             assert(0);
+#endif
         }
 
         Dsymbol *p = d->toParent();
         if (p && !p->isModule()) //for example: char Namespace1::beta[6] should be mangled as "_ZN10Namespace14betaE"
         {
+#if IN_LLVM
+            buf.writestring("_ZN");
+#else
             buf.writestring(global.params.isOSX ? "__ZN" : "_ZN");      // "__Z" for OSX, "_Z" for other
+#endif
             prefix_name(p);
             source_name(d);
             buf.writeByte('E');
@@ -415,13 +441,19 @@ class CppMangleVisitor : public Visitor
         {
             if (!is_temp_arg_ref)
             {
+#if !IN_LLVM
                 if (global.params.isOSX)
                     buf.writeByte('_');
+#endif
                 buf.writestring(d->ident->toChars());
             }
             else
             {
+#if IN_LLVM
+                buf.writestring("_Z");
+#else
                 buf.writestring(global.params.isOSX ? "__Z" : "_Z");
+#endif
                 source_name(d);
             }
         }
@@ -438,7 +470,11 @@ class CppMangleVisitor : public Visitor
          */
         TypeFunction *tf = (TypeFunction *)d->type;
 
+#if IN_LLVM
+        buf.writestring("_Z");
+#else
         buf.writestring(global.params.isOSX ? "__Z" : "_Z");      // "__Z" for OSX, "_Z" for other
+#endif
         Dsymbol *p = d->toParent();
         if (p && !p->isModule() && tf->linkage == LINKcpp)
         {
@@ -511,7 +547,11 @@ class CppMangleVisitor : public Visitor
             // Mangle static arrays as pointers
             t->error(Loc(), "Internal Compiler Error: unable to pass static array to extern(C++) function.");
             t->error(Loc(), "Use pointer instead.");
+#if IN_LLVM
+            fatal();
+#else
             assert(0);
+#endif
             //t = t->nextOf()->pointerTo();
         }
 
@@ -573,7 +613,11 @@ public:
         {
             t->error(Loc(), "Internal Compiler Error: unsupported type %s\n", t->toChars());
         }
+#if IN_LLVM
+        fatal();
+#else
         assert(0); //Assert, because this error should be handled in frontend
+#endif
     }
 
     void visit(TypeBasic *t)
@@ -885,14 +929,18 @@ public:
     }
 };
 
+#if !IN_LLVM
 char *toCppMangle(Dsymbol *s)
 {
     //printf("toCppMangle(%s)\n", s->toChars());
     CppMangleVisitor v;
     return v.mangleOf(s);
 }
+#endif
 
-#elif TARGET_WINDOS
+#if !IN_LLVM
+//#elif TARGET_WINDOS
+#endif
 
 // Windows DMC and Microsoft Visual C++ mangling
 #define VC_SAVED_TYPE_CNT 10
@@ -953,7 +1001,11 @@ public:
         {
             type->error(Loc(), "Internal Compiler Error: unsupported type %s\n", type->toChars());
         }
+#if IN_LLVM
+        fatal();
+#else
         assert(0); // Assert, because this error should be handled in frontend
+#endif
     }
 
     void visit(TypeBasic *type)
@@ -1287,6 +1339,9 @@ public:
 
     char *mangleOf(Dsymbol *s)
     {
+#if IN_LLVM
+        buf.writeByte('\01'); // disable further mangling by the backend
+#endif
         VarDeclaration *vd = s->isVarDeclaration();
         FuncDeclaration *fd = s->isFuncDeclaration();
         if (vd)
@@ -1387,7 +1442,11 @@ private:
         if (!(d->storage_class & (STCextern | STCgshared)))
         {
             d->error("Internal Compiler Error: C++ static non- __gshared non-extern variables not supported");
+#if IN_LLVM
+            fatal();
+#else
             assert(0);
+#endif
         }
         buf.writeByte('?');
         mangleIdent(d);
@@ -1525,7 +1584,11 @@ private:
                     else
                     {
                         sym->error("Internal Compiler Error: C++ %s template value parameter is not supported", tv->valType->toChars());
+#if IN_LLVM
+                        fatal();
+#else
                         assert(0);
+#endif
                     }
                 }
                 else if (!tp || tp->isTemplateTypeParameter())
@@ -1541,7 +1604,11 @@ private:
                     if (!d && !e)
                     {
                         sym->error("Internal Compiler Error: %s is unsupported parameter for C++ template", o->toChars());
+#if IN_LLVM
+                        fatal();
+#else
                         assert(0);
+#endif
                     }
                     if (d && d->isFuncDeclaration())
                     {
@@ -1583,7 +1650,11 @@ private:
                             else
                             {
                                 sym->error("Internal Compiler Error: C++ templates support only integral value, type parameters, alias templates and alias function parameters");
+#if IN_LLVM
+                                fatal();
+#else
                                 assert(0);
+#endif
                             }
                         }
                         tmp.mangleIdent(d);
@@ -1591,14 +1662,22 @@ private:
                     else
                     {
                         sym->error("Internal Compiler Error: %s is unsupported parameter for C++ template: (%s)", o->toChars());
+#if IN_LLVM
+                        fatal();
+#else
                         assert(0);
+#endif
                     }
 
                 }
                 else
                 {
                     sym->error("Internal Compiler Error: C++ templates support only integral value, type parameters, alias templates and alias function parameters");
+#if IN_LLVM
+                    fatal();
+#else
                     assert(0);
+#endif
                 }
             }
             name = tmp.buf.extractString();
@@ -1909,12 +1988,31 @@ private:
     }
 };
 
+#if IN_LLVM
+char *toCppMangle(Dsymbol *s)
+{
+    const bool isTargetWindowsMSVC = global.params.targetTriple.isWindowsMSVCEnvironment();
+    if (isTargetWindowsMSVC)
+    {
+        VisualCPPMangler v(false);
+        return v.mangleOf(s);
+    }
+    else
+    {
+        CppMangleVisitor v;
+        return v.mangleOf(s);
+    }
+}
+#else
 char *toCppMangle(Dsymbol *s)
 {
     VisualCPPMangler v(!global.params.mscoff);
     return v.mangleOf(s);
 }
-
-#else
-#error "fix this"
 #endif
+
+#if !IN_LLVM
+//#else
+//#error "fix this"
+//#endif
+#endif
\ No newline at end of file
diff --git a/src/ctfeexpr.c b/src/ctfeexpr.c
index d0aa614..a35d3e3 100644
--- a/src/ctfeexpr.c
+++ b/src/ctfeexpr.c
@@ -1724,7 +1724,16 @@ UnionExp ctfeCat(Type *type, Expression *e1, Expression *e2)
                 return ue;
             }
             dinteger_t v = es2e->toInteger();
+#if IN_LLVM
+#if __LITTLE_ENDIAN__
+            memcpy((unsigned char *)s + i * sz, &v, sz);
+#else
+            memcpy((unsigned char *)s + i * sz,
+                   (unsigned char *)&v + (sizeof(dinteger_t) - sz), sz);
+#endif
+#else
             memcpy((utf8_t *)s + i * sz, &v, sz);
+#endif
         }
 
         // Add terminating 0
@@ -1758,7 +1767,16 @@ UnionExp ctfeCat(Type *type, Expression *e1, Expression *e2)
                 return ue;
             }
             dinteger_t v = es2e->toInteger();
+#if IN_LLVM
+#if __LITTLE_ENDIAN__
+            memcpy((unsigned char *)s + (es1->len + i) * sz, &v, sz);
+#else
+            memcpy((unsigned char *)s + (es1->len + i) * sz,
+                   (unsigned char *) &v + (sizeof(dinteger_t) - sz), sz);
+#endif
+#else
             memcpy((utf8_t *)s + (es1->len + i) * sz, &v, sz);
+#endif
         }
 
         // Add terminating 0
diff --git a/src/declaration.c b/src/declaration.c
index 3f9209e..b05de4f 100644
--- a/src/declaration.c
+++ b/src/declaration.c
@@ -296,6 +296,24 @@ bool TupleDeclaration::needThis()
     return false;
 }
 
+#if IN_LLVM
+void TupleDeclaration::semantic3(Scope *sc)
+{
+    //printf("TupleDeclaration::semantic3((%s)\n", toChars());
+    for (size_t i = 0; i < objects->dim; i++)
+    {   RootObject *o = (RootObject *)objects->data[i];
+        if (o->dyncast() == DYNCAST_EXPRESSION)
+        {   Expression *e = (Expression *)o;
+            if (e->op == TOKdsymbol)
+            {   DsymbolExp *ve = (DsymbolExp *)e;
+                Declaration *d = ve->s->isDeclaration();
+                d->semantic3(sc);
+            }
+        }
+    }
+}
+#endif
+
 /********************************* AliasDeclaration ****************************/
 
 AliasDeclaration::AliasDeclaration(Loc loc, Identifier *id, Type *type)
@@ -407,6 +425,7 @@ void AliasDeclaration::semantic(Scope *sc)
     }
     else
         type->resolve(loc, sc, &e, &t, &s);
+
     if (s)
     {
         goto L2;
diff --git a/src/declaration.h b/src/declaration.h
index ee4ffba..1c9c08d 100644
--- a/src/declaration.h
+++ b/src/declaration.h
@@ -16,6 +16,10 @@
 #pragma once
 #endif /* __DMC__ */
 
+#if IN_LLVM
+#include <string>
+#endif
+
 #include "dsymbol.h"
 #include "mtype.h"
 
@@ -187,6 +191,10 @@ public:
 
     TupleDeclaration *isTupleDeclaration() { return this; }
     void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    void semantic3(Scope *sc);
+#endif
 };
 
 /**************************************************************/
@@ -519,6 +527,13 @@ public:
 
     const char *mangleString;           // mangled symbol created from mangleExact()
 
+#if IN_LLVM
+    // Argument lists for the __require/__ensure calls. NULL if not a virtual
+    // function with contracts.
+    Expressions *fdrequireParams;
+    Expressions *fdensureParams;
+#endif
+
     Identifier *outId;                  // identifier for out statement
     VarDeclaration *vresult;            // variable corresponding to outId
     LabelDsymbol *returnLabel;          // where the return goes
@@ -564,7 +579,9 @@ public:
     // Support for NRVO (named return value optimization)
     bool nrvo_can;                      // true means we can do it
     VarDeclaration *nrvo_var;           // variable to replace with shidden
+#if IN_DMD
     Symbol *shidden;                    // hidden pointer passed to function
+#endif
 
     ReturnStatements *returns;
 
@@ -647,8 +664,8 @@ public:
     bool needsClosure();
     bool hasNestedFrameRefs();
     void buildResultVar(Scope *sc, Type *tret);
-    Statement *mergeFrequire(Statement *);
-    Statement *mergeFensure(Statement *, Identifier *oid);
+    Statement *mergeFrequire(Statement *, Expressions *params = 0);
+    Statement *mergeFensure(Statement *, Identifier *oid, Expressions *params = 0);
     Parameters *getParameters(int *pvarargs);
 
     static FuncDeclaration *genCfunc(Parameters *args, Type *treturn, const char *name, StorageClass stc=0);
@@ -657,6 +674,18 @@ public:
     FuncDeclaration *isFuncDeclaration() { return this; }
 
     virtual FuncDeclaration *toAliasFunc() { return this; }
+
+#if IN_LLVM
+    std::string intrinsicName;
+    uint32_t priority;
+
+    // true if overridden with the pragma(LDC_allow_inline); stmt
+    bool allowInlining;
+
+    // true if set with the pragma(LDC_never_inline); stmt
+    bool neverInline;
+#endif
+
     void accept(Visitor *v) { v->visit(this); }
 };
 
diff --git a/src/dsymbol.c b/src/dsymbol.c
index d75f676..6279ab6 100644
--- a/src/dsymbol.c
+++ b/src/dsymbol.c
@@ -35,6 +35,10 @@
 #include "enum.h"
 #include "lexer.h"
 
+#if IN_LLVM
+#include "../gen/pragma.h"
+#endif
+const char* Pprotectionnames[] = {NULL, "none", "private", "package", "protected", "public", "export"};
 
 /****************************** Dsymbol ******************************/
 
@@ -43,8 +47,10 @@ Dsymbol::Dsymbol()
     //printf("Dsymbol::Dsymbol(%p)\n", this);
     this->ident = NULL;
     this->parent = NULL;
+#if IN_DMD
     this->csym = NULL;
     this->isym = NULL;
+#endif
     this->loc = Loc();
     this->comment = NULL;
     this->scope = NULL;
@@ -53,6 +59,9 @@ Dsymbol::Dsymbol()
     this->depmsg = NULL;
     this->userAttribDecl = NULL;
     this->ddocUnittest = NULL;
+#if IN_LLVM
+    this->llvmInternal = LLVMnone;
+#endif
 }
 
 Dsymbol::Dsymbol(Identifier *ident)
@@ -60,8 +69,10 @@ Dsymbol::Dsymbol(Identifier *ident)
     //printf("Dsymbol::Dsymbol(%p, ident)\n", this);
     this->ident = ident;
     this->parent = NULL;
+#if IN_DMD
     this->csym = NULL;
     this->isym = NULL;
+#endif
     this->loc = Loc();
     this->comment = NULL;
     this->scope = NULL;
@@ -70,6 +81,9 @@ Dsymbol::Dsymbol(Identifier *ident)
     this->depmsg = NULL;
     this->userAttribDecl = NULL;
     this->ddocUnittest = NULL;
+#if IN_LLVM
+    this->llvmInternal = LLVMnone;
+#endif
 }
 
 Dsymbol *Dsymbol::create(Identifier *ident)
diff --git a/src/dsymbol.h b/src/dsymbol.h
index 4bf5427..49c6676 100644
--- a/src/dsymbol.h
+++ b/src/dsymbol.h
@@ -23,6 +23,14 @@
 #include "arraytypes.h"
 #include "visitor.h"
 
+#if IN_LLVM
+#if defined(_MSC_VER)
+#undef min
+#undef max
+#endif
+#include "../ir/irdsymbol.h"
+#endif
+
 class Identifier;
 struct Scope;
 class DsymbolTable;
@@ -53,7 +61,9 @@ class UnitTestDeclaration;
 class NewDeclaration;
 class VarDeclaration;
 class AttribDeclaration;
+#if IN_DMD
 struct Symbol;
+#endif
 class Package;
 class Module;
 class Import;
@@ -147,8 +157,10 @@ class Dsymbol : public RootObject
 public:
     Identifier *ident;
     Dsymbol *parent;
+#if IN_DMD
     Symbol *csym;               // symbol for code generator
     Symbol *isym;               // import version of csym
+#endif
     const utf8_t *comment;      // documentation comment for this Dsymbol
     Loc loc;                    // where defined
     Scope *scope;               // !=NULL means context to use for semantic()
@@ -275,6 +287,12 @@ public:
     virtual AttribDeclaration *isAttribDeclaration() { return NULL; }
     virtual OverloadSet *isOverloadSet() { return NULL; }
     virtual void accept(Visitor *v) { v->visit(this); }
+#if IN_LLVM
+    // llvm stuff
+    int llvmInternal;
+
+    IrDsymbol ir;
+#endif
 };
 
 // Dsymbol that generates a scope
diff --git a/src/enum.c b/src/enum.c
index 7cba57f..2ff3418 100644
--- a/src/enum.c
+++ b/src/enum.c
@@ -34,7 +34,9 @@ EnumDeclaration::EnumDeclaration(Loc loc, Identifier *id, Type *memtype)
     maxval = NULL;
     minval = NULL;
     defaultval = NULL;
+#if IN_DMD
     sinit = NULL;
+#endif
     isdeprecated = false;
     protection = Prot(PROTundefined);
     parent = NULL;
diff --git a/src/enum.h b/src/enum.h
index 30bd800..01a71a5 100644
--- a/src/enum.h
+++ b/src/enum.h
@@ -65,7 +65,10 @@ public:
 
     EnumDeclaration *isEnumDeclaration() { return this; }
 
+#if IN_DMD
     Symbol *sinit;
+#endif
+
     void accept(Visitor *v) { v->visit(this); }
 };
 
diff --git a/src/errors.c b/src/errors.c
index 428d3f3..6599e8e 100644
--- a/src/errors.c
+++ b/src/errors.c
@@ -12,8 +12,13 @@
 #include <stdio.h>
 
 #if _WIN32
+#define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #include <io.h>
+#if IN_LLVM
+#undef min
+#undef max
+#endif
 #endif
 
 #if __linux__ || __APPLE__ || __FreeBSD__ || __OpenBSD__ || __sun
diff --git a/src/expression.c b/src/expression.c
index a5742a1..65c3c2e 100644
--- a/src/expression.c
+++ b/src/expression.c
@@ -42,6 +42,10 @@
 #include "nspace.h"
 #include "ctfe.h"
 
+#if IN_LLVM
+#include "gen/pragma.h"
+#endif
+
 bool typeMerge(Scope *sc, TOK op, Type **pt, Expression **pe1, Expression **pe2);
 bool isArrayOpValid(Expression *e);
 Expression *expandVar(int result, VarDeclaration *v);
@@ -119,6 +123,13 @@ Expression *getRightThis(Loc loc, Scope *sc, AggregateDeclaration *ad,
                     {
                         //printf("rewriting e1 to %s's this\n", f->toChars());
                         n++;
+#if IN_LLVM
+                        // LDC seems dmd misses it sometimes here :/
+                        if (f->isMember2()) {
+                            f->vthis->nestedrefs.push(sc->parent->isFuncDeclaration());
+                            f->closureVars.push(f->vthis);
+                        }
+#endif
                         e1 = new VarExp(loc, f->vthis);
                     }
                     else
@@ -1700,7 +1711,12 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,
             // These will be the trailing ... arguments
 
             // If not D linkage, do promotions
+#if IN_LLVM
+            // LDC: don't do promotions on intrinsics
+            if (tf->linkage != LINKd && (!fd || !DtoIsIntrinsic(fd)))
+#else
             if (tf->linkage != LINKd)
+#endif
             {
                 // Promote bytes, words, etc., to ints
                 arg = integralPromotions(arg, sc);
@@ -1911,6 +1927,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,
     }
     //if (eprefix) printf("eprefix: %s\n", eprefix->toChars());
 
+#if !IN_LLVM
     // If D linkage and variadic, add _arguments[] as first argument
     if (tf->linkage == LINKd && tf->varargs == 1)
     {
@@ -1929,7 +1946,7 @@ bool functionParameters(Loc loc, Scope *sc, TypeFunction *tf,
         e = e->semantic(sc);
         arguments->insert(0, e);
     }
-
+#endif
     Type *tret = tf->next;
     if (isCtorCall)
     {
@@ -1979,6 +1996,10 @@ Expression::Expression(Loc loc, TOK op, int size)
     this->size = (unsigned char)size;
     this->parens = 0;
     type = NULL;
+
+#if IN_LLVM
+    cachedLvalue = NULL;
+#endif
 }
 
 void Expression::init()
@@ -4315,10 +4336,16 @@ StructLiteralExp::StructLiteralExp(Loc loc, StructDeclaration *sd, Expressions *
     this->elements = elements;
     this->stype = stype;
     this->sinit = NULL;
+#if IN_DMD
     this->sym = NULL;
+#endif
     this->soffset = 0;
     this->fillHoles = 1;
     this->ownedByCtfe = OWNEDcode;
+#if IN_LLVM
+    this->inProgressMemory = NULL;
+    this->globalVar = NULL;
+#endif
     this->origin = this;
     this->stageflags = 0;
     this->inlinecopy = NULL;
@@ -4472,12 +4499,14 @@ Expression *StructLiteralExp::getField(Type *type, unsigned offset)
                 e = e->copy();
                 e->type = type;
             }
+#if !IN_LLVM
             if (sinit && e->op == TOKstructliteral &&
                 e->type->needsNested())
             {
                 StructLiteralExp *se = (StructLiteralExp *)e;
                 se->sinit = toInitializer(se->sd);
             }
+#endif
         }
     }
     return e;
@@ -5239,6 +5268,14 @@ Expression *SymOffExp::semantic(Scope *sc)
 
 bool SymOffExp::isBool(bool result)
 {
+#if IN_LLVM
+    // For a weak symbol, we only statically know that it is non-null if the
+    // offset is non-zero.
+    if (var->llvmInternal == LLVMextern_weak)
+    {
+        return result && offset != 0;
+    }
+#endif
     return result ? true : false;
 }
 
@@ -5844,6 +5881,10 @@ MATCH FuncExp::matchType(Type *to, Scope *sc, FuncExp **presult, int flag)
 
             // Bugzilla 12508: Tweak function body for covariant returns.
             (*presult)->fd->modifyReturns(sc, tof->next);
+#if IN_LLVM
+            // Also, update function return type.
+            (*presult)->fd->type = tof;
+#endif
         }
     }
     else if (!flag)
@@ -8459,7 +8500,11 @@ Lagain:
                  * otherwise the literals expressed as code get excessively large.
                  */
                 if (sd->size(loc) > Target::ptrsize * 4 && !t1->needsNested())
+#if IN_LLVM
+                    {} // FIXME!!!
+#else
                     sle->sinit = toInitializer(sd);
+#endif
 
                 Expression *e = sle;
                 if (CtorDeclaration *cf = sd->ctor->isCtorDeclaration())
@@ -9239,6 +9284,14 @@ Expression *AddrExp::semantic(Scope *sc)
         FuncDeclaration *f = ve->var->isFuncDeclaration();
         if (f)
         {
+#if IN_LLVM
+            if (DtoIsIntrinsic(f))
+            {
+                error("cannot take the address of intrinsic function %s", e1->toChars());
+                return this;
+            }
+#endif
+
             /* Because nested functions cannot be overloaded,
              * mark here that we took its address because castTo()
              * may not be called with an exact match.
diff --git a/src/expression.h b/src/expression.h
index c23cc53..96240dd 100644
--- a/src/expression.h
+++ b/src/expression.h
@@ -41,14 +41,29 @@ class TemplateInstance;
 class TemplateDeclaration;
 class ClassDeclaration;
 class BinExp;
+#if IN_DMD
 struct Symbol;          // back end symbol
+#endif
 class OverloadSet;
 class Initializer;
 class StringExp;
 class ArrayExp;
 class SliceExp;
+#if IN_LLVM
+class AssignExp;
+class SymbolDeclaration;
+#endif
+
 struct UnionExp;
 
+#if IN_LLVM
+struct IRState;
+namespace llvm {
+    class GlobalVariable;
+    class Value;
+}
+#endif
+
 void initPrecedence();
 
 Expression *resolveProperties(Scope *sc, Expression *e);
@@ -213,6 +228,9 @@ public:
     }
 
     virtual void accept(Visitor *v) { v->visit(this); }
+#if IN_LLVM
+    llvm::Value* cachedLvalue;
+#endif
 };
 
 class IntegerExp : public Expression
@@ -461,8 +479,10 @@ public:
                                 // NULL entries for fields to skip
     Type *stype;                // final type of result (can be different from sd's type)
 
+#if IN_DMD
     Symbol *sinit;              // if this is a defaultInitLiteral, this symbol contains the default initializer
     Symbol *sym;                // back end symbol to initialize with literal
+#endif
     size_t soffset;             // offset from start of s
     int fillHoles;              // fill alignment 'holes' with zero
     OwnedBy ownedByCtfe;
@@ -490,6 +510,22 @@ public:
     Expression *getField(Type *type, unsigned offset);
     int getFieldIndex(Type *type, unsigned offset);
     Expression *addDtorHook(Scope *sc);
+#if IN_LLVM
+    // With the introduction of pointers returned from CTFE, struct literals can
+    // now contain pointers to themselves. While in toElem, contains a pointer
+    // to the memory used to build the literal for resolving such references.
+    llvm::Value* inProgressMemory;
+
+    // A global variable for taking the address of this struct literal constant,
+    // if it already exists. Used to resolve self-references.
+    llvm::GlobalVariable *globalVar;
+
+    /// Set if this is really the result of a struct .init access and should be
+    /// resolved codegen'd as an access to the given SymbolDeclaration.
+    // LDC_FIXME: Figure out whether this, i.e. imitating the DMD behavior, is
+    // really the best way to fix the nested struct constant folding issue.
+    SymbolDeclaration *sinit;
+#endif
 
     void accept(Visitor *v) { v->visit(this); }
 };
diff --git a/src/func.c b/src/func.c
index 8814237..f0903e4 100644
--- a/src/func.c
+++ b/src/func.c
@@ -290,6 +290,10 @@ FuncDeclaration::FuncDeclaration(Loc loc, Loc endloc, Identifier *id, StorageCla
     fdrequire = NULL;
     fdensure = NULL;
     mangleString = NULL;
+#if IN_LLVM
+    fdrequireParams = NULL;
+    fdensureParams = NULL;
+#endif
     outId = NULL;
     vresult = NULL;
     returnLabel = NULL;
@@ -327,13 +331,22 @@ FuncDeclaration::FuncDeclaration(Loc loc, Loc endloc, Identifier *id, StorageCla
     hasReturnExp = 0;
     nrvo_can = 1;
     nrvo_var = NULL;
+#if IN_DMD
     shidden = NULL;
+#endif
     builtin = BUILTINunknown;
     tookAddressOf = 0;
     requiresClosure = false;
     flags = 0;
     returns = NULL;
     gotos = NULL;
+
+#if IN_LLVM
+    // LDC
+    isArrayOp = false;
+    allowInlining = false;
+    neverInline = false;
+#endif
 }
 
 Dsymbol *FuncDeclaration::syntaxCopy(Dsymbol *s)
@@ -347,9 +360,39 @@ Dsymbol *FuncDeclaration::syntaxCopy(Dsymbol *s)
     f->fensure  = fensure  ? fensure->syntaxCopy()  : NULL;
     f->fbody    = fbody    ? fbody->syntaxCopy()    : NULL;
     assert(!fthrows); // deprecated
+
+#if IN_LLVM
+    f->intrinsicName = intrinsicName;
+#endif
+
     return f;
 }
 
+#if IN_LLVM
+static int outToRefDg(void *ctx, size_t n, Parameter *p)
+{
+    if (p->storageClass & STCout)
+    {
+        // Cannot just use syntaxCopy() here, because it would cause the
+        // parameter type to be semantic()ed again, in the wrong scope. So,
+        // just copy the outer layer to modify the storage class.
+        void *cpy = malloc(sizeof(Parameter));
+        memcpy(cpy, (void *)p, sizeof(Parameter));
+        p = (Parameter *)cpy;
+        p->storageClass &= ~STCout;
+        p->storageClass |= STCref;
+    }
+    ((Parameters *)ctx)->push(p);
+    return 0;
+}
+static Parameters *outToRef(Parameters* params)
+{
+    Parameters *result = new Parameters();
+    Parameter::foreach(params, &outToRefDg, result);
+    return result;
+}
+#endif
+
 // Do the semantic analysis on the external interface to the function.
 
 void FuncDeclaration::semantic(Scope *sc)
@@ -1102,13 +1145,30 @@ void FuncDeclaration::semantic(Scope *sc)
          */
         if (frequire)
         {
+#if IN_LLVM
+            /* In LDC, we can't rely on the codegen hacks DMD has to be able
+             * to just magically call the contract function parameterless with
+             * the parameters being picked up from the outer stack frame.
+             *
+             * Thus, we actually pass all the function parameters to the
+             * __require call, rewriting out parameters to ref ones because
+             * they have already been zeroed in the outer function.
+             *
+             * Also initialize fdrequireParams here - it will get filled in
+             * in semantic3.
+             */
+            fdrequireParams = new Expressions();
+            Parameters *params = outToRef(((TypeFunction*)type)->parameters);
+            TypeFunction *tf = new TypeFunction(params, Type::tvoid, 0, LINKd);
+#else
             /*   in { ... }
              * becomes:
              *   void __require() { ... }
              *   __require();
              */
-            Loc loc = frequire->loc;
             TypeFunction *tf = new TypeFunction(NULL, Type::tvoid, 0, LINKd);
+#endif
+            Loc loc = frequire->loc;
             tf->isnothrow = f->isnothrow;
             tf->isnogc = f->isnogc;
             tf->purity = f->purity;
@@ -1117,7 +1177,11 @@ void FuncDeclaration::semantic(Scope *sc)
                 Id::require, STCundefined, tf);
             fd->fbody = frequire;
             Statement *s1 = new ExpStatement(loc, fd);
+#if IN_LLVM
+            Expression *e = new CallExp(loc, new VarExp(loc, fd, 0), fdrequireParams);
+#else
             Expression *e = new CallExp(loc, new VarExp(loc, fd, 0), (Expressions *)NULL);
+#endif
             Statement *s2 = new ExpStatement(loc, e);
             frequire = new CompoundStatement(loc, s1, s2);
             fdrequire = fd;
@@ -1126,20 +1190,39 @@ void FuncDeclaration::semantic(Scope *sc)
         if (!outId && f->nextOf() && f->nextOf()->toBasetype()->ty != Tvoid)
             outId = Id::result; // provide a default
 
+#if IN_LLVM
+        /* We need to initialize fdensureParams here and not in the block below
+         * to have the parameter available when calling a base class ensure(),
+         * even if this functions doesn't have an out contract.
+         */
+        fdensureParams = new Expressions();
+        if (outId)
+            fdensureParams->push(new IdentifierExp(loc, outId));
+#endif
+
         if (fensure)
         {
+            Loc loc = fensure->loc;
+#if IN_LLVM
+            /* Same as for in contracts, see above. */
+            Parameters *fparams = outToRef(((TypeFunction*)type)->parameters);
+#else
             /*   out (result) { ... }
              * becomes:
              *   void __ensure(ref tret result) { ... }
              *   __ensure(result);
              */
-            Loc loc = fensure->loc;
             Parameters *fparams = new Parameters();
+#endif
             Parameter *p = NULL;
             if (outId)
             {
                 p = new Parameter(STCref | STCconst, f->nextOf(), outId, NULL);
+#if IN_LLVM
+                fparams->insert(0, p);
+#else
                 fparams->push(p);
+#endif
             }
             TypeFunction *tf = new TypeFunction(fparams, Type::tvoid, 0, LINKd);
             tf->isnothrow = f->isnothrow;
@@ -1150,10 +1233,14 @@ void FuncDeclaration::semantic(Scope *sc)
                 Id::ensure, STCundefined, tf);
             fd->fbody = fensure;
             Statement *s1 = new ExpStatement(loc, fd);
+#if IN_LLVM
+            Expression *e = new CallExp(loc, new VarExp(loc, fd, 0), fdensureParams);
+#else
             Expression *eresult = NULL;
             if (outId)
                 eresult = new IdentifierExp(loc, outId);
             Expression *e = new CallExp(loc, new VarExp(loc, fd, 0), eresult);
+#endif
             Statement *s2 = new ExpStatement(loc, e);
             fensure = new CompoundStatement(loc, s1, s2);
             fdensure = fd;
@@ -1189,7 +1276,13 @@ Ldone:
     }
 
     Module::dprogress++;
+#if IN_LLVM
+    //LDC relies on semanticRun variable not being reset here
+    if(semanticRun < PASSsemanticdone)
+        semanticRun = PASSsemanticdone;
+#else
     semanticRun = PASSsemanticdone;
+#endif
 
     /* Save scope for possible later use (if we need the
      * function internals)
@@ -1362,7 +1455,7 @@ void FuncDeclaration::semantic3(Scope *sc)
         // Declare hidden variable _arguments[] and _argptr
         if (f->varargs == 1)
         {
-#ifndef IN_GCC
+#if !IN_GCC && !IN_LLVM
             if (global.params.is64bit && !global.params.isWindows)
             {
                 // Declare save area for varargs registers
@@ -1413,6 +1506,29 @@ void FuncDeclaration::semantic3(Scope *sc)
             }
         }
 
+#if IN_LLVM
+        // Make sure semantic analysis has been run on argument types. This is
+        // e.g. needed for TypeTuple!(int, int) to be picked up as two int
+        // parameters by the Parameter functions.
+        if (f->parameters)
+        {
+            for (size_t i = 0; i < Parameter::dim(f->parameters); i++)
+            {   Parameter *arg = (Parameter *)Parameter::getNth(f->parameters, i);
+                Type* nw = arg->type->semantic(Loc(), sc);
+                if (arg->type != nw) {
+                    arg->type = nw;
+                    // Examine this index again.
+                    // This is important if it turned into a tuple.
+                    // In particular, the empty tuple should be handled or the
+                    // next parameter will be skipped.
+                    // LDC_FIXME: Maybe we only need to do this for tuples,
+                    //            and can add tuple.length after decrement?
+                    i--;
+                }
+            }
+        }
+#endif
+
         /* Declare all the function parameters as variables
          * and install them in parameters[]
          */
@@ -1452,6 +1568,12 @@ void FuncDeclaration::semantic3(Scope *sc)
                     parameters->push(v);
                 localsymtab->insert(v);
                 v->parent = this;
+#if IN_LLVM
+                if (fdrequireParams)
+                    fdrequireParams->push(new VarExp(loc, v));
+                if (fdensureParams)
+                    fdensureParams->push(new VarExp(loc, v));
+#endif
             }
         }
 
@@ -1914,10 +2036,12 @@ void FuncDeclaration::semantic3(Scope *sc)
                 }
             }
 
+// we'll handle variadics ourselves
+#if !IN_LLVM
             if (argptr)
             {
                 // Initialize _argptr
-#ifdef IN_GCC
+#if IN_GCC
                 // Handled in FuncDeclaration::toObjFile
                 v_argptr = argptr;
                 v_argptr->init = new VoidInitializer(loc);
@@ -2016,6 +2140,8 @@ void FuncDeclaration::semantic3(Scope *sc)
                 a->push(new ExpStatement(Loc(), de));
             }
 
+#endif // !IN_LLVM
+
             // Merge contracts together with body into one compound statement
 
             if (freq || fpreinv)
@@ -2044,8 +2170,20 @@ void FuncDeclaration::semantic3(Scope *sc)
 
                 if (f->next->ty != Tvoid && vresult)
                 {
+#if IN_LLVM
+                    Expression *e = 0;
+                    if (isCtorDeclaration()) {
+                        ThisExp *te = new ThisExp(Loc());
+                        te->type = vthis->type;
+                        te->var = vthis;
+                        e = te;
+                    } else {
+                        e = new VarExp(Loc(), vresult);
+                    }
+#else
                     // Create: return vresult;
                     Expression *e = new VarExp(Loc(), vresult);
+#endif
                     if (tintro)
                     {
                         e = e->implicitCastTo(sc, tintro->nextOf());
@@ -2424,8 +2562,11 @@ void FuncDeclaration::buildResultVar(Scope *sc, Type *tret)
  * 'in's are OR'd together, i.e. only one of them needs to pass.
  */
 
-Statement *FuncDeclaration::mergeFrequire(Statement *sf)
+Statement *FuncDeclaration::mergeFrequire(Statement *sf, Expressions *params)
 {
+    if (!params)
+        params = fdrequireParams;
+
     /* If a base function and its override both have an IN contract, then
      * only one of them needs to succeed. This is done by generating:
      *
@@ -2442,6 +2583,11 @@ Statement *FuncDeclaration::mergeFrequire(Statement *sf)
      * If base.in() throws, then derived.in()'s body is executed.
      */
 
+#if IN_LLVM
+    /* In LDC, we can't rely on these codegen hacks - we explicitly pass
+     * parameters on to the contract functions.
+     */
+#else
     /* Implementing this is done by having the overriding function call
      * nested functions (the fdrequire functions) nested inside the overridden
      * function. This requires that the stack layout of the calling function's
@@ -2458,6 +2604,7 @@ Statement *FuncDeclaration::mergeFrequire(Statement *sf)
      *     a stack local, allocate that local immediately following the exception
      *     handler block, so it is always at the same offset from EBP.
      */
+#endif
     for (size_t i = 0; i < foverrides.dim; i++)
     {
         FuncDeclaration *fdv = foverrides[i];
@@ -2474,7 +2621,11 @@ Statement *FuncDeclaration::mergeFrequire(Statement *sf)
             sc->pop();
         }
 
+#if IN_LLVM
+        sf = fdv->mergeFrequire(sf, params);
+#else
         sf = fdv->mergeFrequire(sf);
+#endif
         if (sf && fdv->fdrequire)
         {
             //printf("fdv->frequire: %s\n", fdv->frequire->toChars());
@@ -2482,8 +2633,12 @@ Statement *FuncDeclaration::mergeFrequire(Statement *sf)
              *   try { __require(); }
              *   catch { frequire; }
              */
+#if IN_LLVM
+            Expression *e = new CallExp(loc, new VarExp(loc, fdv->fdrequire, 0), params);
+#else
             Expression *eresult = NULL;
             Expression *e = new CallExp(loc, new VarExp(loc, fdv->fdrequire, 0), eresult);
+#endif
             Statement *s2 = new ExpStatement(loc, e);
 
             Catch *c = new Catch(loc, NULL, NULL, sf);
@@ -2503,8 +2658,17 @@ Statement *FuncDeclaration::mergeFrequire(Statement *sf)
  * 'out's are AND'd together, i.e. all of them need to pass.
  */
 
+#if IN_LLVM
+Statement *FuncDeclaration::mergeFensure(Statement *sf, Identifier *oid, Expressions *params)
+#else
 Statement *FuncDeclaration::mergeFensure(Statement *sf, Identifier *oid)
+#endif
 {
+#if IN_LLVM
+    if (!params)
+        params = fdensureParams;
+#endif
+
     /* Same comments as for mergeFrequire(), except that we take care
      * of generating a consistent reference to the 'result' local by
      * explicitly passing 'result' to the nested function as a reference
@@ -2530,7 +2694,11 @@ Statement *FuncDeclaration::mergeFensure(Statement *sf, Identifier *oid)
             sc->pop();
         }
 
+#if IN_LLVM
+        sf = fdv->mergeFensure(sf, oid, params);
+#else
         sf = fdv->mergeFensure(sf, oid);
+#endif
         if (fdv->fdensure)
         {
             //printf("fdv->fensure: %s\n", fdv->fensure->toChars());
@@ -2538,9 +2706,18 @@ Statement *FuncDeclaration::mergeFensure(Statement *sf, Identifier *oid)
             Expression *eresult = NULL;
             if (outId)
             {
+#if IN_LLVM
+                eresult = (*params)[0];
+#else
                 eresult = new IdentifierExp(loc, oid);
+#endif
 
                 Type *t1 = fdv->type->nextOf()->toBasetype();
+#if IN_LLVM
+                // We actually check for matching types in CommaExp::toElem,
+                // 'testcontract' breaks without this.
+                t1 = t1->constOf();
+#endif
                 Type *t2 = this->type->nextOf()->toBasetype();
                 if (t1->isBaseOf(t2, NULL))
                 {
@@ -2556,7 +2733,13 @@ Statement *FuncDeclaration::mergeFensure(Statement *sf, Identifier *oid)
                     eresult = new CommaExp(Loc(), de, ve);
                 }
             }
+#if IN_LLVM
+            if (eresult)
+                (*params)[0] = eresult;
+            Expression *e = new CallExp(loc, new VarExp(loc, fdv->fdensure, 0), params);
+#else
             Expression *e = new CallExp(loc, new VarExp(loc, fdv->fdensure, 0), eresult);
+#endif
             Statement *s2 = new ExpStatement(loc, e);
 
             if (sf)
@@ -4077,7 +4260,14 @@ Expression *addInvariant(Loc loc, Scope *sc, AggregateDeclaration *ad, VarDeclar
     #endif
 
         // Call invariant virtually
+#if IN_LLVM
+        // We actually need a valid 'var' for codegen.
+        ThisExp* tv = new ThisExp(Loc());
+        tv->var = vthis;
+        Expression *v = tv;
+#else
         Expression *v = new ThisExp(Loc());
+#endif
         v->type = vthis->type;
         if (ad->isStructDeclaration())
             v = v->addressOf();
@@ -5062,7 +5252,7 @@ void StaticDtorDeclaration::semantic(Scope *sc)
         Statement *s = new ExpStatement(Loc(), v);
         sa->push(s);
         Expression *e = new IdentifierExp(Loc(), v->ident);
-        e = new AddAssignExp(Loc(), e, new IntegerExp(-1));
+        e = new AddAssignExp(Loc(), e, new IntegerExp(-1)); // LDC_FIXME: Previously had (uint64_t)-1, double-check this.
         e = new EqualExp(TOKnotequal, Loc(), e, new IntegerExp(0));
         s = new IfStatement(Loc(), NULL, e, new ReturnStatement(Loc(), NULL), NULL);
         sa->push(s);
diff --git a/src/globals.c b/src/globals.c
index 217828e..1749340 100644
--- a/src/globals.c
+++ b/src/globals.c
@@ -25,6 +25,13 @@ void Global::init()
     json_ext = "json";
     map_ext  = "map";
 
+#if IN_LLVM
+    ll_ext  = "ll";
+    bc_ext  = "bc";
+    s_ext   = "s";
+    obj_ext = "o";
+    obj_ext_alt = "obj";
+#else
 #if TARGET_WINDOS
     obj_ext  = "obj";
 #elif TARGET_LINUX || TARGET_OSX || TARGET_FREEBSD || TARGET_OPENBSD || TARGET_SOLARIS
@@ -59,19 +66,32 @@ void Global::init()
 #else
 #error "fix this"
 #endif
+#endif
 
     copyright = "Copyright (c) 1999-2015 by Digital Mars";
     written = "written by Walter Bright";
+#if IN_LLVM
+    compiler.vendor = "LDC";
+#else
     version = "v"
 #include "verstr.h"
     ;
 
     compiler.vendor = "Digital Mars D";
+#endif
     stdmsg = stdout;
 
     main_d = "__main.d";
 
+    // This should only be used as a global, so the other fields are
+    // automatically initialized to zero when the program is loaded.
+    // In particular, DO NOT zero-initialize .params here (like DMD
+    // does) because command-line options initialize some of those
+    // fields to non-zero defaults, and do so from constructors that
+    // may run before this one.
+#if !IN_LLVM
     memset(&params, 0, sizeof(Param));
+#endif
 
     errorLimit = 20;
 }
diff --git a/src/globals.h b/src/globals.h
index 5851f36..2ff4b19 100644
--- a/src/globals.h
+++ b/src/globals.h
@@ -23,6 +23,19 @@
 // Can't include arraytypes.h here, need to declare these directly.
 template <typename TYPE> struct Array;
 
+#if IN_LLVM
+#include "llvm/ADT/Triple.h"
+
+enum OUTPUTFLAG
+{
+    OUTPUTFLAGno,
+    OUTPUTFLAGdefault, // for the .o default
+    OUTPUTFLAGset // for -output
+};
+
+typedef unsigned char ubyte;
+#endif
+
 // The state of array bounds checking
 enum BOUNDSCHECK
 {
@@ -32,33 +45,47 @@ enum BOUNDSCHECK
     BOUNDSCHECKsafeonly // do bounds checking only in @safe functions
 };
 
-
 // Put command line switches in here
 struct Param
 {
     bool obj;           // write object file
     bool link;          // perform link
+#if !IN_LLVM
     bool dll;           // generate shared dynamic library
     bool lib;           // write library file instead of object file(s)
     bool multiobj;      // break one object file into multiple ones
     bool oneobj;        // write one object file instead of multiple ones
+#endif
     bool trace;         // insert profiling hooks
     bool tracegc;       // instrument calls to 'new'
     bool verbose;       // verbose compile
     bool showColumns;   // print character (column) numbers in diagnostics
     bool vtls;          // identify thread local variables
+#if !IN_LLVM
     char vgc;           // identify gc usage
+#else
+    bool vgc;           // identify gc usage
+#endif
     bool vfield;        // identify non-mutable field variables
     bool vcomplex;      // identify complex/imaginary type usage
+#if !IN_LLVM
     char symdebug;      // insert debug symbolic information
+#else
+    ubyte symdebug;     // insert debug symbolic information
+#endif
     bool alwaysframe;   // always emit standard stack frame
     bool optimize;      // run optimizer
+#if !IN_LLVM
     bool map;           // generate linker .map file
+#endif
     bool is64bit;       // generate 64 bit code
     bool isLP64;        // generate code for LP64
+#if !IN_LLVM
     bool isLinux;       // generate code for linux
     bool isOSX;         // generate code for Mac OSX
+#endif
     bool isWindows;     // generate code for Windows
+#if !IN_LLVM
     bool isFreeBSD;     // generate code for FreeBSD
     bool isOpenBSD;     // generate code for OpenBSD
     bool isSolaris;     // generate code for Solaris
@@ -66,6 +93,11 @@ struct Param
     char useDeprecated; // 0: don't allow use of deprecated features
                         // 1: silently allow use of deprecated features
                         // 2: warn about the use of deprecated features
+#else
+    ubyte useDeprecated; // 0: don't allow use of deprecated features
+                         // 1: silently allow use of deprecated features
+                         // 2: warn about the use of deprecated features
+#endif
     bool useAssert;     // generate runtime code for assert()'s
     bool useInvariants; // generate class invariant checks
     bool useIn;         // generate precondition checks
@@ -75,11 +107,28 @@ struct Param
     bool useUnitTests;  // generate unittest code
     bool useInline;     // inline expand functions
     bool useDIP25;      // implement http://wiki.dlang.org/DIP25
+#if !IN_LLVM
     bool release;       // build release version
     bool preservePaths; // true means don't strip path from source file
     char warnings;      // 0: disable warnings
                         // 1: warnings as errors
                         // 2: informational warnings (no errors)
+#else
+    ubyte warnings;      // 0: disable warnings
+                         // 1: warnings as errors
+                         // 2: informational warnings (no errors)
+#endif
+
+#if IN_LLVM
+    bool color;         // use ANSI colors in console output
+    bool cov;           // generate code coverage data
+    unsigned char covPercent;   // 0..100 code coverage percentage required
+    bool ignoreUnsupportedPragmas;      // rather than error on them
+    bool enforcePropertySyntax;
+    bool addMain; // LDC_FIXME: Implement.
+    bool allInst; // LDC_FIXME: Implement.
+    unsigned nestedTmpl; // maximum nested template instantiations
+#else
     bool pic;           // generate position-independent-code for shared libs
     bool color;         // use ANSI colors in console output
     bool cov;           // generate code coverage data
@@ -90,6 +139,7 @@ struct Param
     bool betterC;       // be a "better C" compiler; no dependency on D runtime
     bool addMain;       // add a default main() function
     bool allInst;       // generate code for all template instantiations
+#endif
 
     BOUNDSCHECK useArrayBounds;
 
@@ -118,12 +168,15 @@ struct Param
     unsigned versionlevel; // version level
     Array<const char *> *versionids;   // version identifiers
 
+#if !IN_LLVM
     const char *defaultlibname; // default library for non-debug builds
     const char *debuglibname;   // default library for debug builds
+#endif
 
     const char *moduleDepsFile; // filename for deps output
     OutBuffer *moduleDeps;      // contents to be written to deps file
 
+#if !IN_LLVM
     // Hidden debug switches
     bool debugb;
     bool debugc;
@@ -131,9 +184,12 @@ struct Param
     bool debugr;
     bool debugx;
     bool debugy;
+#endif
 
     bool run;           // run resulting executable
+#if !IN_LLVM
     Strings runargs;    // arguments for executable
+#endif
 
     // Linker stuff
     Array<const char *> *objfiles;
@@ -144,6 +200,27 @@ struct Param
     const char *resfile;
     const char *exefile;
     const char *mapfile;
+#if IN_LLVM
+    // Whether to keep all function bodies in .di file generation or to strip
+    // those of plain functions. For DMD, this is govenered by the -inline
+    // flag, which does not directly translate to LDC.
+    bool hdrKeepAllBodies;
+
+    // LDC stuff
+    OUTPUTFLAG output_ll;
+    OUTPUTFLAG output_bc;
+    OUTPUTFLAG output_s;
+    OUTPUTFLAG output_o;
+    bool useInlineAsm;
+    bool verbose_cg;
+
+    // target stuff
+    llvm::Triple targetTriple;
+
+    // Codegen cl options
+    bool singleObj;
+    bool disableRedZone;
+#endif
 };
 
 struct Compiler
@@ -160,6 +237,12 @@ struct Global
     const char *inifilename;
     const char *mars_ext;
     const char *obj_ext;
+#if IN_LLVM
+    const char *obj_ext_alt;
+    const char *ll_ext;
+    const char *bc_ext;
+    const char *s_ext;
+#endif
     const char *lib_ext;
     const char *dll_ext;
     const char *doc_ext;        // for Ddoc generated files
@@ -176,6 +259,10 @@ struct Global
     Array<const char *> *filePath;    // Array of char*'s which form the file import lookup path
 
     const char *version;
+#if IN_LLVM
+    const char *ldc_version;
+    const char *llvm_version;
+#endif
 
     Compiler compiler;
     Param params;
diff --git a/src/hdrgen.c b/src/hdrgen.c
index 023b1f2..dcaf618 100644
--- a/src/hdrgen.c
+++ b/src/hdrgen.c
@@ -1781,7 +1781,13 @@ public:
                 bodyToBuffer(f);
                 hgs->autoMember--;
             }
-            else if (hgs->tpltMember == 0 && !global.params.useInline)
+            else if (hgs->tpltMember == 0 &&
+#if IN_LLVM
+                     !global.params.hdrKeepAllBodies
+#else
+                     !global.params.useInline
+#endif
+                    )
             {
                 buf->writeByte(';');
                 buf->writenl();
@@ -1795,7 +1801,13 @@ public:
 
     void bodyToBuffer(FuncDeclaration *f)
     {
-        if (!f->fbody || (hgs->hdrgen && !global.params.useInline && !hgs->autoMember && !hgs->tpltMember))
+        if (!f->fbody || (hgs->hdrgen &&
+#if IN_LLVM
+                          !global.params.hdrKeepAllBodies
+#else
+                          !global.params.useInline
+#endif
+                          && !hgs->autoMember && !hgs->tpltMember))
         {
             buf->writeByte(';');
             buf->writenl();
@@ -2221,6 +2233,12 @@ public:
         ld_sprint(buffer, 'g', value);
         assert(strlen(buffer) < BUFFER_LEN);
 
+#if IN_LLVM
+#if _MSC_VER
+        // MSVC: LLVM's APFloat is used for strtold, which asserts for certain special float inputs
+        if (!Port::isNan(value) && !Port::isInfinity(value))
+#endif
+#endif
         if (hgs->hdrgen)
         {
             real_t r = Port::strtold(buffer, NULL);
diff --git a/src/inline.c b/src/inline.c
index 6fdaf59..53b45c0 100644
--- a/src/inline.c
+++ b/src/inline.c
@@ -383,8 +383,11 @@ public:
         // can't handle that at present.
         if (e->e1->op == TOKdotvar && ((DotVarExp *)e->e1)->e1->op == TOKsuper)
             cost = COST_MAX;
+#if !IN_LLVM
+        // In LDC, we only use the inliner for default arguments anyway.
         else if (e->f && e->f->ident == Id::__alloca && e->f->linkage == LINKc && !allowAlloca)
             cost = COST_MAX; // inlining alloca may cause stack overflows
+#endif
         else
             cost++;
     }
@@ -865,8 +868,10 @@ Expression *doInline(Expression *e, InlineDoState *ids)
                     VarDeclaration *vto = new VarDeclaration(vd->loc, vd->type, vd->ident, vd->init);
                     memcpy((void *)vto, (void *)vd, sizeof(VarDeclaration));
                     vto->parent = ids->parent;
+#if IN_DMD
                     vto->csym = NULL;
                     vto->isym = NULL;
+#endif
 
                     ids->from.push(vd);
                     ids->to.push(vto);
@@ -1022,8 +1027,10 @@ Expression *doInline(Expression *e, InlineDoState *ids)
                 VarDeclaration *vto = new VarDeclaration(vd->loc, vd->type, vd->ident, vd->init);
                 memcpy((void*)vto, (void*)vd, sizeof(VarDeclaration));
                 vto->parent = ids->parent;
+#if IN_DMD
                 vto->csym = NULL;
                 vto->isym = NULL;
+#endif
 
                 ids->from.push(vd);
                 ids->to.push(vto);
@@ -1055,8 +1062,10 @@ Expression *doInline(Expression *e, InlineDoState *ids)
                 VarDeclaration *vto = new VarDeclaration(vd->loc, vd->type, vd->ident, vd->init);
                 memcpy((void*)vto, (void*)vd, sizeof(VarDeclaration));
                 vto->parent = ids->parent;
+#if IN_DMD
                 vto->csym = NULL;
                 vto->isym = NULL;
+#endif
 
                 ids->from.push(vd);
                 ids->to.push(vto);
diff --git a/src/lexer.c b/src/lexer.c
index 8f26026..af6c729 100644
--- a/src/lexer.c
+++ b/src/lexer.c
@@ -9,6 +9,12 @@
  * https://github.com/D-Programming-Language/dmd/blob/master/src/lexer.c
  */
 
+#if IN_LLVM
+#include <cmath>
+#endif
+
+#include <sstream>
+
 /* Lexical Analyzer */
 
 #include <stdio.h>
@@ -17,7 +23,11 @@
 #include <stdarg.h>
 #include <errno.h>
 #include <wchar.h>
+#if IN_LLVM
+#include <cstdlib>
+#else
 #include <stdlib.h>
+#endif
 #include <assert.h>
 #include <time.h>       // for time() and ctime()
 
diff --git a/src/mars.c b/src/mars.c
index 7b2aa31..f6d5b93 100644
--- a/src/mars.c
+++ b/src/mars.c
@@ -14,7 +14,8 @@
 #include <ctype.h>
 #include <assert.h>
 #include <limits.h>
-#include <string.h>
+#include <string>
+#include <cstdarg>
 
 #if __linux__ || __APPLE__ || __FreeBSD__ || __OpenBSD__ || __sun
 #include <errno.h>
@@ -22,7 +23,9 @@
 
 #include "rmem.h"
 #include "root.h"
+#if !IN_LLVM
 #include "async.h"
+#endif
 #include "target.h"
 #include "file.h"
 #include "filename.h"
@@ -35,18 +38,21 @@
 #include "id.h"
 #include "cond.h"
 #include "expression.h"
+#if !IN_LLVM
 #include "parse.h"
 #include "lib.h"
 #include "json.h"
+#endif
 #include "declaration.h"
 #include "hdrgen.h"
 #include "doc.h"
 
+#if !IN_LLVM
 bool response_expand(Strings *arguments);
 
-
 void browse(const char *url);
 void getenv_setargv(const char *envvalue, Strings *args);
+#endif
 
 void printCtfePerformanceStats();
 
@@ -129,6 +135,11 @@ static void logo()
         global.version, global.copyright, global.written);
 }
 
+#if !IN_LLVM
+
+extern void backend_init();
+extern void backend_term();
+
 static void usage()
 {
 #if TARGET_LINUX
@@ -1747,7 +1758,6 @@ int main(int argc, const char *argv[])
     return status;
 }
 
-
 /***********************************
  * Parse and append contents of command line string envvalue to args[].
  * The string is separated into arguments, processing \ and ".
@@ -1833,6 +1843,8 @@ void getenv_setargv(const char *envvalue, Strings *args)
     }
 }
 
+#endif // !IN_LLVM
+
 void escapePath(OutBuffer *buf, const char *fname)
 {
     while (1)
diff --git a/src/mars.h b/src/mars.h
index 897e394..0935813 100644
--- a/src/mars.h
+++ b/src/mars.h
@@ -63,6 +63,12 @@ the target object file format:
 #include <stdio.h>
 #include <stdint.h>
 #include <stdarg.h>
+#include <stddef.h>
+#include <stdarg.h>
+
+#if IN_LLVM
+#include "llvm/ADT/Triple.h"
+#endif
 
 #ifdef __DMC__
 #ifdef DEBUG
@@ -83,13 +89,17 @@ struct OutBuffer;
 
 #include "errors.h"
 
+#if !IN_LLVM
 class Dsymbol;
 class Library;
+#endif
 struct File;
+#if !IN_LLVM
 void obj_start(char *srcfile);
 void obj_end(Library *library, File *objfile);
 void obj_append(Dsymbol *s);
 void obj_write_deferred(Library *library);
+#endif
 
 void readFile(Loc loc, File *f);
 void writeFile(Loc loc, File *f);
diff --git a/src/module.c b/src/module.c
index 7758b32..9a3ff6a 100644
--- a/src/module.c
+++ b/src/module.c
@@ -64,6 +64,7 @@ Module::Module(const char *filename, Identifier *ident, int doDocComment, int do
     searchCacheSymbol = NULL;
     searchCacheFlags = 0;
     decldefs = NULL;
+#if IN_DMD
     massert = NULL;
     munittest = NULL;
     marray = NULL;
@@ -74,9 +75,12 @@ Module::Module(const char *filename, Identifier *ident, int doDocComment, int do
     sshareddtor = NULL;
     stest = NULL;
     sfilename = NULL;
+#endif
     importedFrom = NULL;
     srcfile = NULL;
+    objfile = NULL;
     docfile = NULL;
+    hdrfile = NULL;
 
     debuglevel = 0;
     debugids = NULL;
@@ -87,9 +91,11 @@ Module::Module(const char *filename, Identifier *ident, int doDocComment, int do
 
     macrotable = NULL;
     escapetable = NULL;
+#if IN_DMD
     doppelganger = 0;
     cov = NULL;
     covb = NULL;
+#endif
 
     nameoffset = 0;
     namelen = 0;
@@ -113,6 +119,7 @@ Module::Module(const char *filename, Identifier *ident, int doDocComment, int do
     }
     srcfile = new File(srcfilename);
 
+#if IN_DMD
     objfile = setOutfile(global.params.objname, global.params.objdir, filename, global.obj_ext);
 
     if (doDocComment)
@@ -122,6 +129,17 @@ Module::Module(const char *filename, Identifier *ident, int doDocComment, int do
         hdrfile = setOutfile(global.params.hdrname, global.params.hdrdir, arg, global.hdr_ext);
 
     //objfile = new File(objfilename);
+#endif
+#if IN_LLVM
+    // LDC
+    llvmForceLogging = false;
+    noModuleInfo = false;
+    this->doDocComment = doDocComment;
+    this->doHdrGen = doHdrGen;
+    this->arrayfuncs = 0;
+    d_cover_valid = NULL;
+    d_cover_data = NULL;
+#endif
 }
 
 Module *Module::create(const char *filename, Identifier *ident, int doDocComment, int doHdrGen)
@@ -129,6 +147,7 @@ Module *Module::create(const char *filename, Identifier *ident, int doDocComment
     return new Module(filename, ident, doDocComment, doHdrGen);
 }
 
+#if IN_DMD
 void Module::setDocfile()
 {
     docfile = setOutfile(global.params.docname, global.params.docdir, arg, global.doc_ext);
@@ -177,12 +196,15 @@ File *Module::setOutfile(const char *name, const char *dir, const char *arg, con
 
     return new File(docfilename);
 }
+#endif
 
 void Module::deleteObjFile()
 {
     if (global.params.obj)
         objfile->remove();
-    if (docfile)
+    //if (global.params.llvmBC)
+    //bcfile->remove();
+    if (doDocComment && docfile)
         docfile->remove();
 }
 
@@ -260,8 +282,13 @@ bool Module::read(Loc loc)
         if (!strcmp(srcfile->toChars(), "object.d"))
         {
             ::error(loc, "cannot find source code for runtime library file 'object.d'");
-            errorSupplemental(loc, "dmd might not be correctly installed. Run 'dmd -man' for installation instructions.");
+#if IN_LLVM
+            errorSupplemental(loc, "ldc2 might not be correctly installed.");
+            errorSupplemental(loc, "Please check your ldc2.conf configuration file.");
+            errorSupplemental(loc, "Installation instructions can be found at http://wiki.dlang.org/LDC.");
+#else
             errorSupplemental(loc, "config file: %s", FileName::canonicalName(global.inifilename));
+#endif
         }
         else
         {
@@ -297,7 +324,7 @@ bool Module::read(Loc loc)
     return true;
 }
 
-Module *Module::parse()
+Module *Module::parse(bool gen_docs)
 {
     //printf("Module::parse(srcfile='%s') this=%p\n", srcfile->name->toChars(), this);
 
@@ -477,12 +504,20 @@ Module *Module::parse()
     {
         comment = buf + 4;
         isDocFile = 1;
+#if IN_LLVM
+        doDocComment = true;
+#else
         if (!docfile)
             setDocfile();
+#endif
         return this;
     }
     {
+#if IN_LLVM
+        Parser p(this, buf, buflen, gen_docs);
+#else
         Parser p(this, buf, buflen, docfile != NULL);
+#endif
         p.nextToken();
         members = p.parseModule();
         md = p.md;
@@ -854,7 +889,7 @@ void Module::semantic3()
 int Module::needModuleInfo()
 {
     //printf("needModuleInfo() %s, %d, %d\n", toChars(), needmoduleinfo, global.params.cov);
-    return needmoduleinfo || global.params.cov;
+    return needmoduleinfo;
 }
 
 Dsymbol *Module::search(Loc loc, Identifier *ident, int flags)
diff --git a/src/module.h b/src/module.h
index f297cc4..1df914d 100644
--- a/src/module.h
+++ b/src/module.h
@@ -26,6 +26,16 @@ struct Escape;
 class VarDeclaration;
 class Library;
 
+#if IN_LLVM
+class DValue;
+namespace llvm {
+    class LLVMContext;
+    class Module;
+    class GlobalVariable;
+    class StructType;
+}
+#endif
+
 enum PKG
 {
     PKGunknown, // not yet determined whether it's a package.d or not
@@ -114,17 +124,32 @@ public:
     size_t nameoffset;          // offset of module name from start of ModuleInfo
     size_t namelen;             // length of module name in characters
 
+    int doDocComment;          // enable generating doc comments for this module
+    int doHdrGen;              // enable generating header file for this module
+
     Module(const char *arg, Identifier *ident, int doDocComment, int doHdrGen);
     static Module* create(const char *arg, Identifier *ident, int doDocComment, int doHdrGen);
+    ~Module();
 
     static Module *load(Loc loc, Identifiers *packages, Identifier *ident);
 
     const char *kind();
+#if !IN_LLVM
     File *setOutfile(const char *name, const char *dir, const char *arg, const char *ext);
-    void setDocfile();
+    void setDocfile();  // set docfile member
+#endif
     bool read(Loc loc); // read file, returns 'true' if succeed, 'false' otherwise.
-    Module *parse();    // syntactic parse
+#if IN_LLVM
+    Module *parse(bool gen_docs = false);       // syntactic parse
+#else
+    Module *parse();       // syntactic parse
+#endif
     void importAll(Scope *sc);
+#if IN_LLVM
+    using Package::semantic;
+    using Dsymbol::semantic2;
+    using Dsymbol::semantic3;
+#endif
     void semantic();    // semantic analysis
     void semantic2();   // pass 2 semantic analysis
     void semantic3();   // pass 3 semantic analysis
@@ -144,7 +169,7 @@ public:
                                 // listed in command line.
 
     // Back end
-
+#if IN_DMD
     int doppelganger;           // sub-module
     Symbol *cov;                // private uint[] __coverage;
     unsigned *covb;             // bit array of valid code line numbers
@@ -161,6 +186,25 @@ public:
     Symbol *massert;            // module assert function
     Symbol *munittest;          // module unittest failure function
     Symbol *marray;             // module array bounds function
+#endif
+
+#if IN_LLVM
+    // LDC
+    llvm::Module* genLLVMModule(llvm::LLVMContext& context);
+    void buildTargetFiles(bool singleObj, bool library);
+    File* buildFilePath(const char* forcename, const char* path, const char* ext);
+
+    bool llvmForceLogging;
+    bool noModuleInfo; /// Do not emit any module metadata.
+
+    // array ops emitted in this module already
+    AA *arrayfuncs;
+
+    // Coverage analysis
+    llvm::GlobalVariable* d_cover_valid;  // private immutable size_t[] _d_cover_valid;
+    llvm::GlobalVariable* d_cover_data;   // private uint[] _d_cover_data;
+    std::vector<size_t> d_cover_valid_init; // initializer for _d_cover_valid
+#endif
 
     Module *isModule() { return this; }
     void accept(Visitor *v) { v->visit(this); }
diff --git a/src/mtype.c b/src/mtype.c
index 92319ea..d4f05b0 100644
--- a/src/mtype.c
+++ b/src/mtype.c
@@ -12,7 +12,11 @@
 #define __C99FEATURES__ 1       // Needed on Solaris for NaN and more
 #define __USE_ISOC99 1          // so signbit() gets defined
 
+#ifdef __DMC__
 #include <math.h>
+#else
+#include <cmath>
+#endif
 #include <stdio.h>
 #include <assert.h>
 #include <float.h>
@@ -2097,7 +2101,12 @@ Expression *Type::getProperty(Loc loc, Identifier *ident, int flag)
         if (tb->ty == Tstruct && tb->needsNested())
         {
             StructLiteralExp *se = (StructLiteralExp *)e;
+#if IN_LLVM
+            se->sinit = (SymbolDeclaration*)
+                (((VarExp*)defaultInit(loc))->var);
+#else
             se->sinit = toInitializer(se->sd);
+#endif
         }
     }
     else if (ident == Id::mangleof)
@@ -2181,6 +2190,16 @@ Expression *Type::dotExp(Scope *sc, Expression *e, Identifier *ident, int flag)
         }
         else if (ident == Id::init)
         {
+#if IN_LLVM
+            // LDC_FIXME: Port the below (from 2.061).
+            if (toBasetype()->ty == Tstruct &&
+                ((TypeStruct *)toBasetype())->sym->isNested())
+            {
+                e = defaultInit(e->loc);
+            }
+            else
+                e = defaultInitLiteral(e->loc);
+#else
             Type *tb = toBasetype();
             e = defaultInitLiteral(e->loc);
             if (tb->ty == Tstruct && tb->needsNested())
@@ -2188,6 +2207,7 @@ Expression *Type::dotExp(Scope *sc, Expression *e, Identifier *ident, int flag)
                 StructLiteralExp *se = (StructLiteralExp *)e;
                 se->sinit = toInitializer(se->sd);
             }
+#endif
             goto Lreturn;
         }
     }
@@ -2334,8 +2354,10 @@ Identifier *Type::getTypeInfoIdent(int internal)
     assert(strlen(name) < namelen);     // don't overflow the buffer
 
     size_t off = 0;
+#if !IN_LLVM
     if (global.params.isOSX || global.params.isWindows && !global.params.is64bit)
         ++off;                 // C mangling will add '_' back in
+#endif
     Identifier *id = Identifier::idPool(name + off);
 
     if (name != namebuf)
@@ -2980,6 +3002,17 @@ unsigned TypeBasic::alignsize()
     return Target::alignsize(this);
 }
 
+#if IN_LLVM
+unsigned TypeBasic::alignment()
+{
+    if (global.params.targetTriple.getArch() == llvm::Triple::x86_64 &&
+        (ty == Tfloat80 || ty == Timaginary80) && size(Loc()) > 8)
+    {
+        return 16;
+    }
+    return Type::alignment();
+}
+#endif
 
 Expression *TypeBasic::getProperty(Loc loc, Identifier *ident, int flag)
 {
@@ -3587,10 +3620,14 @@ Expression *TypeVector::dotExp(Scope *sc, Expression *e, Identifier *ident, int
 #endif
     if (ident == Id::array)
     {
+#if IN_LLVM
+        e = e->castTo(sc, basetype);
+#else
         //e = e->castTo(sc, basetype);
         // Keep lvalue-ness
         e = e->copy();
         e->type = basetype;
+#endif
         return e;
     }
     if (ident == Id::init || ident == Id::offsetof || ident == Id::stringof)
@@ -7607,6 +7644,10 @@ TypeStruct::TypeStruct(StructDeclaration *sym)
 {
     this->sym = sym;
     this->att = RECfwdref;
+
+#if IN_LLVM
+    this->unaligned = 0;
+#endif
 }
 
 const char *TypeStruct::kind()
@@ -7968,7 +8009,12 @@ Expression *TypeStruct::defaultInitLiteral(Loc loc)
      * otherwise the literals expressed as code get excessively large.
      */
     if (size(loc) > Target::ptrsize * 4 && !needsNested())
+#if IN_LLVM
+        structinit->sinit = static_cast<SymbolDeclaration *>(
+            static_cast<VarExp *>(defaultInit(loc))->var);
+#else
         structinit->sinit = toInitializer(sym);
+#endif
 
     structinit->type = this;
     return structinit;
diff --git a/src/mtype.h b/src/mtype.h
index 344c1f6..a7db978 100644
--- a/src/mtype.h
+++ b/src/mtype.h
@@ -21,7 +21,7 @@
 
 #include "arraytypes.h"
 #include "expression.h"
-#include "visitor.h"
+//#include "visitor.h"
 
 struct Scope;
 class Identifier;
@@ -41,6 +41,8 @@ class Parameter;
 // Back end
 #ifdef IN_GCC
 typedef union tree_node type;
+#elif IN_LLVM
+typedef class IrType type;
 #else
 typedef struct TYPE type;
 #endif
@@ -341,8 +343,8 @@ public:
     virtual bool needsNested();
     void checkComplexTransition(Loc loc);
 
-    static void error(Loc loc, const char *format, ...);
-    static void warning(Loc loc, const char *format, ...);
+    static void error(Loc loc, const char *format, ...) IS_PRINTF(2);
+    static void warning(Loc loc, const char *format, ...) IS_PRINTF(2);
 
     // For eliminating dynamic_cast
     virtual TypeBasic *isTypeBasic();
@@ -398,6 +400,9 @@ public:
     Type *syntaxCopy();
     d_uns64 size(Loc loc);
     unsigned alignsize();
+#if IN_LLVM
+    unsigned alignment();
+#endif
     Expression *getProperty(Loc loc, Identifier *ident, int flag);
     Expression *dotExp(Scope *sc, Expression *e, Identifier *ident, int flag);
     bool isintegral();
@@ -786,6 +791,13 @@ public:
     Type *toHeadMutable();
 
     void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    // LDC
+    // cache the hasUnalignedFields check
+    // 0 = not checked, 1 = aligned, 2 = unaligned
+    int unaligned;
+#endif
 };
 
 class TypeEnum : public Type
diff --git a/src/opover.c b/src/opover.c
index 6734d7f..4978605 100644
--- a/src/opover.c
+++ b/src/opover.c
@@ -14,6 +14,15 @@
 #include <ctype.h>
 #include <assert.h>
 #include <string.h>                     // memset()
+#if _MSC_VER || IN_LLVM // complex.h breaks LLVM headers.
+#include <complex>
+#else
+#include <complex.h>
+#endif
+
+#ifdef __APPLE__
+#define integer_t dmd_integer_t
+#endif
 
 #include "rmem.h"
 
diff --git a/src/parse.c b/src/parse.c
index 79cde77..b665fde 100644
--- a/src/parse.c
+++ b/src/parse.c
@@ -4067,6 +4067,12 @@ L2:
                     new TemplateDeclaration(loc, ident, tpl, NULL, a2, 0);
                 s = tempdecl;
             }
+            if (structalign != 0)
+            {
+                Dsymbols *ax = new Dsymbols();
+                ax->push(s);
+                s = new AlignDeclaration(structalign, ax);
+            }
             if (link != linkage)
             {
                 Dsymbols *ax = new Dsymbols();
diff --git a/src/root/array.h b/src/root/array.h
index 840afb0..d86b308 100644
--- a/src/root/array.h
+++ b/src/root/array.h
@@ -18,6 +18,11 @@
 #include <stdlib.h>
 #include <string.h>
 
+#if IN_LLVM
+#include "llvm/Support/Compiler.h"
+#include <iterator>
+#endif
+
 #include "object.h"
 #include "rmem.h"
 
@@ -169,8 +174,13 @@ struct Array
     #endif
             Array_sort_compare(const void *x, const void *y)
             {
+#if IN_LLVM
+                RootObject *ox = *static_cast<RootObject **>(const_cast<void *>(x));
+                RootObject *oy = *static_cast<RootObject **>(const_cast<void *>(y));
+#else
                 RootObject *ox = *(RootObject **)x;
                 RootObject *oy = *(RootObject **)y;
+#endif
 
                 return ox->compare(oy);
             }
@@ -235,6 +245,127 @@ struct Array
         memcpy(a->data, data, dim * sizeof(*data));
         return a;
     }
+
+#if IN_LLVM
+    // Define members and types like std::vector
+    typedef size_t size_type;
+
+    Array(const Array<TYPE> &a) : dim(0), data(0), allocdim(0)
+    {
+        setDim(a.dim);
+        memcpy(data, a.data, dim * sizeof(*data));
+    }
+
+    Array &operator=(Array<TYPE> &a)
+    {
+        setDim(a.dim);
+        memcpy(data, a.data, dim * sizeof(*data));
+        return *this;
+    }
+
+#if LLVM_HAS_RVALUE_REFERENCES
+    Array(Array<TYPE> &&a)
+    {
+        if (data != &smallarray[0])
+            mem.xfree(data);
+        dim = a.dim;
+        allocdim = a.allocdim;
+        if (a.data == &a.smallarray[0])
+        {
+            data = &smallarray[0];
+            memcpy(data, a.data, dim * sizeof(*data));
+        }
+        else
+        {
+            data = a.data;
+            a.data = 0;
+        }
+        a.dim = 0;
+        a.allocdim = 0;
+    }
+
+    Array &operator=(Array<TYPE> &&a)
+    {
+        if (data != &smallarray[0])
+            mem.xfree(data);
+        dim = a.dim;
+        allocdim = a.allocdim;
+        if (a.data == &a.smallarray[0])
+        {
+            data = &smallarray[0];
+            memcpy(data, a.data, dim * sizeof(*data));
+        }
+        else
+        {
+            data = a.data;
+            a.data = 0;
+        }
+        a.dim = 0;
+        a.allocdim = 0;
+        return *this;
+    }
+#endif
+
+    size_type size()
+    {
+        return static_cast<size_type>(dim);
+    }
+
+    bool empty()
+    {
+        return dim == 0;
+    }
+
+    TYPE front()
+    {
+        return data[0];
+    }
+
+    TYPE back()
+    {
+        return data[dim-1];
+    }
+
+    void push_back(TYPE a)
+    {
+        push(a);
+    }
+
+    void pop_back()
+    {
+        pop();
+    }
+
+    typedef TYPE *iterator;
+    typedef std::reverse_iterator<iterator> reverse_iterator;
+
+    iterator begin()
+    {
+        return static_cast<iterator>(&data[0]);
+    }
+
+    iterator end()
+    {
+        return static_cast<iterator>(&data[dim]);
+    }
+
+    reverse_iterator rbegin()
+    {
+        return reverse_iterator(end());
+    }
+
+    reverse_iterator rend()
+    {
+        return reverse_iterator(begin());
+    }
+
+    iterator erase(iterator pos)
+    {
+        size_t index = pos - &data[0];
+        remove(index);
+        return static_cast<iterator>(&data[index]);
+    }
+#endif
 };
 
 #endif
diff --git a/src/root/longdouble.h b/src/root/longdouble.h
index 8f046f6..b7f9f67 100644
--- a/src/root/longdouble.h
+++ b/src/root/longdouble.h
@@ -11,7 +11,6 @@
 #ifndef __LONG_DOUBLE_H__
 #define __LONG_DOUBLE_H__
 
-#if !_MSC_VER // has native 10 byte doubles
 #include <stdio.h>
 typedef long double longdouble;
 typedef volatile long double volatile_longdouble;
@@ -48,192 +47,4 @@ inline size_t ld_sprint(char* str, int fmt, longdouble x)
 #undef sprintf
 #endif
 
-#else
-
-#include <float.h>
-#include <limits>
-
-struct longdouble;
-
-extern "C"
-{
-    // implemented in ldfpu.asm for _WIN64
-    double ld_read(const longdouble* ld);
-    long long ld_readll(const longdouble* ld);
-    unsigned long long ld_readull(const longdouble* ld);
-    void ld_set(longdouble* ld, double d);
-    void ld_setll(longdouble* ld, long long d);
-    void ld_setull(longdouble* ld, unsigned long long d);
-}
-
-struct longdouble
-{
-    unsigned long long mantissa;
-    unsigned short exponent:15;  // bias 0x3fff
-    unsigned short sign:1;
-    unsigned short fill:16;      // for 12 byte alignment
-
-    // no constructor to be able to use this class in a union
-    // use ldouble() to explicitely create a longdouble value
-
-    template<typename T> longdouble& operator=(T x) { set(x); return *this; }
-
-    void set(longdouble ld) { mantissa = ld.mantissa; exponent = ld.exponent; sign = ld.sign; }
-
-    // we need to list all basic types to avoid ambiguities
-    void set(float              d) { ld_set(this, d); }
-    void set(double             d) { ld_set(this, d); }
-    void set(long double        d) { ld_set(this, d); }
-
-    void set(signed char        d) { ld_set(this, d); }
-    void set(short              d) { ld_set(this, d); }
-    void set(int                d) { ld_set(this, d); }
-    void set(long               d) { ld_set(this, d); }
-    void set(long long          d) { ld_setll(this, d); }
-
-    void set(unsigned char      d) { ld_set(this, d); }
-    void set(unsigned short     d) { ld_set(this, d); }
-    void set(unsigned int       d) { ld_set(this, d); }
-    void set(unsigned long      d) { ld_set(this, d); }
-    void set(unsigned long long d) { ld_setull(this, d); }
-    void set(bool               d) { ld_set(this, d); }
-
-    operator float             () { return ld_read(this); }
-    operator double            () { return ld_read(this); }
-
-    operator signed char       () { return ld_read(this); }
-    operator short             () { return ld_read(this); }
-    operator int               () { return ld_read(this); }
-    operator long              () { return ld_read(this); }
-    operator long long         () { return ld_readll(this); }
-
-    operator unsigned char     () { return ld_read(this); }
-    operator unsigned short    () { return ld_read(this); }
-    operator unsigned int      () { return ld_read(this); }
-    operator unsigned long     () { return ld_read(this); }
-    operator unsigned long long() { return ld_readull(this); }
-    operator bool              () { return mantissa != 0 || exponent != 0; } // correct?
-};
-
-// some optimizations are avoided by adding volatile to the longdouble
-// type, but this introduces bad ambiguities when using the class implementation above
-// as we are going through asm these optimizations won't kick in anyway, so "volatile"
-// is not required.
-typedef longdouble volatile_longdouble;
-
-inline longdouble ldouble(unsigned long long mantissa, int exp, int sign = 0)
-{
-    longdouble d;
-    d.mantissa = mantissa;
-    d.exponent = exp;
-    d.sign = sign;
-    return d;
-}
-
-// codegen bug in VS2010/VS2012, if the set() function not inlined
-//  (this passed on stack, but expected in ECX; RVO?)
-#if _MSC_VER >= 1600
-#define LDOUBLE_INLINE __declspec(noinline)
-#else
-#define LDOUBLE_INLINE inline
-#endif
-
-template<typename T> LDOUBLE_INLINE longdouble ldouble(T x) { longdouble d; d.set(x); return d; }
-
-#undef LDOUBLE_INLINE
-
-longdouble operator+(longdouble ld1, longdouble ld2);
-longdouble operator-(longdouble ld1, longdouble ld2);
-longdouble operator*(longdouble ld1, longdouble ld2);
-longdouble operator/(longdouble ld1, longdouble ld2);
-
-bool operator< (longdouble ld1, longdouble ld2);
-bool operator<=(longdouble ld1, longdouble ld2);
-bool operator> (longdouble ld1, longdouble ld2);
-bool operator>=(longdouble ld1, longdouble ld2);
-bool operator==(longdouble ld1, longdouble ld2);
-bool operator!=(longdouble ld1, longdouble ld2);
-
-inline longdouble operator-(longdouble ld1) { ld1.sign ^= 1; return ld1; }
-inline longdouble operator+(longdouble ld1) { return ld1; }
-
-template<typename T> inline longdouble operator+(longdouble ld, T x) { return ld + ldouble(x); }
-template<typename T> inline longdouble operator-(longdouble ld, T x) { return ld - ldouble(x); }
-template<typename T> inline longdouble operator*(longdouble ld, T x) { return ld * ldouble(x); }
-template<typename T> inline longdouble operator/(longdouble ld, T x) { return ld / ldouble(x); }
-
-template<typename T> inline longdouble operator+(T x, longdouble ld) { return ldouble(x) + ld; }
-template<typename T> inline longdouble operator-(T x, longdouble ld) { return ldouble(x) - ld; }
-template<typename T> inline longdouble operator*(T x, longdouble ld) { return ldouble(x) * ld; }
-template<typename T> inline longdouble operator/(T x, longdouble ld) { return ldouble(x) / ld; }
-
-template<typename T> inline longdouble& operator+=(longdouble& ld, T x) { return ld = ld + x; }
-template<typename T> inline longdouble& operator-=(longdouble& ld, T x) { return ld = ld - x; }
-template<typename T> inline longdouble& operator*=(longdouble& ld, T x) { return ld = ld * x; }
-template<typename T> inline longdouble& operator/=(longdouble& ld, T x) { return ld = ld / x; }
-
-template<typename T> inline bool operator< (longdouble ld, T x) { return ld <  ldouble(x); }
-template<typename T> inline bool operator<=(longdouble ld, T x) { return ld <= ldouble(x); }
-template<typename T> inline bool operator> (longdouble ld, T x) { return ld >  ldouble(x); }
-template<typename T> inline bool operator>=(longdouble ld, T x) { return ld >= ldouble(x); }
-template<typename T> inline bool operator==(longdouble ld, T x) { return ld == ldouble(x); }
-template<typename T> inline bool operator!=(longdouble ld, T x) { return ld != ldouble(x); }
-
-template<typename T> inline bool operator< (T x, longdouble ld) { return ldouble(x) <  ld; }
-template<typename T> inline bool operator<=(T x, longdouble ld) { return ldouble(x) <= ld; }
-template<typename T> inline bool operator> (T x, longdouble ld) { return ldouble(x) >  ld; }
-template<typename T> inline bool operator>=(T x, longdouble ld) { return ldouble(x) >= ld; }
-template<typename T> inline bool operator==(T x, longdouble ld) { return ldouble(x) == ld; }
-template<typename T> inline bool operator!=(T x, longdouble ld) { return ldouble(x) != ld; }
-
-int _isnan(longdouble ld);
-
-longdouble fabsl(longdouble ld);
-longdouble sqrtl(longdouble ld);
-longdouble sinl (longdouble ld);
-longdouble cosl (longdouble ld);
-longdouble tanl (longdouble ld);
-
-longdouble fmodl(longdouble x, longdouble y);
-longdouble ldexpl(longdouble ldval, int exp); // see strtold
-
-inline longdouble fabs (longdouble ld) { return fabsl(ld); }
-inline longdouble sqrt (longdouble ld) { return sqrtl(ld); }
-
-#undef LDBL_DIG
-#undef LDBL_MAX
-#undef LDBL_MIN
-#undef LDBL_EPSILON
-#undef LDBL_MANT_DIG
-#undef LDBL_MAX_EXP
-#undef LDBL_MIN_EXP
-#undef LDBL_MAX_10_EXP
-#undef LDBL_MIN_10_EXP
-
-#define LDBL_DIG        18
-#define LDBL_MAX        ldouble(0xffffffffffffffffULL, 0x7ffe)
-#define LDBL_MIN        ldouble(0x8000000000000000ULL, 1)
-#define LDBL_EPSILON    ldouble(0x8000000000000000ULL, 0x3fff - 63) // allow denormal?
-#define LDBL_MANT_DIG   64
-#define LDBL_MAX_EXP    16384
-#define LDBL_MIN_EXP    (-16381)
-#define LDBL_MAX_10_EXP 4932
-#define LDBL_MIN_10_EXP (-4932)
-
-extern longdouble ld_zero;
-extern longdouble ld_one;
-extern longdouble ld_pi;
-extern longdouble ld_log2t;
-extern longdouble ld_log2e;
-extern longdouble ld_log2;
-extern longdouble ld_ln2;
-
-extern longdouble ld_inf;
-extern longdouble ld_qnan;
-extern longdouble ld_snan;
-
-size_t ld_sprint(char* str, int fmt, longdouble x);
-
-#endif // !_MSC_VER
-
 #endif // __LONG_DOUBLE_H__
diff --git a/src/root/newdelete.c b/src/root/newdelete.c
index 8f62b88..2ab5faf 100644
--- a/src/root/newdelete.c
+++ b/src/root/newdelete.c
@@ -17,9 +17,9 @@
 #endif
 #endif
 
-#if !defined(USE_ASAN_NEW_DELETE)
+#if !defined(USE_ASAN_NEW_DELETE) && !defined(IN_LLVM)
 
-#if 1
+#if IN_DMD
 
 void *allocmemory(size_t m_size);
 
diff --git a/src/root/object.h b/src/root/object.h
index 2474223..1898c3e 100644
--- a/src/root/object.h
+++ b/src/root/object.h
@@ -10,7 +10,9 @@
 #ifndef OBJECT_H
 #define OBJECT_H
 
+#if !IN_LLVM
 #define POSIX (__linux__ || __APPLE__ || __FreeBSD__ || __OpenBSD__ || __sun)
+#endif
 
 #if __DMC__
 #pragma once
diff --git a/src/root/port.c b/src/root/port.c
index dc80fa3..a2a32cd 100644
--- a/src/root/port.c
+++ b/src/root/port.c
@@ -160,6 +160,8 @@ longdouble Port::strtold(const char *buffer, char **endp)
 // Disable useless warnings about unreferenced functions
 #pragma warning (disable : 4514)
 
+#include <llvm/ADT/APFloat.h>
+#include <llvm/ADT/StringRef.h>
 #include <math.h>
 #include <float.h>  // for _isnan
 #include <time.h>
@@ -169,6 +171,11 @@ longdouble Port::strtold(const char *buffer, char **endp)
 #include <wchar.h>
 #include <stdlib.h>
 #include <limits> // for std::numeric_limits
+#include "target.h"
+
+#if IN_LLVM
+#include "llvm/Support/ErrorHandling.h"
+#endif
 
 double Port::nan;
 longdouble Port::ldbl_nan;
@@ -181,6 +188,10 @@ double Port::dbl_max = DBL_MAX;
 double Port::dbl_min = DBL_MIN;
 longdouble Port::ldbl_max = LDBL_MAX;
 
+#if IN_LLVM
+bool Port::yl2x_supported = false;
+bool Port::yl2xp1_supported = false;
+#else
 #if _M_IX86 || _M_X64
 bool Port::yl2x_supported = true;
 bool Port::yl2xp1_supported = true;
@@ -188,6 +199,7 @@ bool Port::yl2xp1_supported = true;
 bool Port::yl2x_supported = false;
 bool Port::yl2xp1_supported = false;
 #endif
+#endif
 
 struct PortInitializer
 {
@@ -198,28 +210,52 @@ static PortInitializer portinitializer;
 
 PortInitializer::PortInitializer()
 {
+#if IN_LLVM
     union {
         unsigned long ul[2];
         double d;
-    } nan = {{ 0, 0x7FF80000 }};
+    }
+    nan = { { 0, 0x7FF80000 } },
+    snan = { { 0, 0x7FFC0000 } },
+    inf = { { 0, 0x7FF00000 } };
+
+    Port::nan = nan.d;
+    Port::ldbl_nan = nan.d;
+    Port::snan = snan.d;
+    Port::infinity = inf.d;
+    Port::ldbl_infinity = inf.d;
+#else
+    union {
+        unsigned long ul[2];
+        double d;
+    } nan = { { 0, 0x7FF80000 } };
 
     Port::nan = nan.d;
     Port::ldbl_nan = ld_qnan;
     Port::snan = ld_snan;
     Port::infinity = std::numeric_limits<double>::infinity();
     Port::ldbl_infinity = ld_inf;
+#endif
 
     _set_abort_behavior(_WRITE_ABORT_MSG, _WRITE_ABORT_MSG | _CALL_REPORTFAULT); // disable crash report
 }
 
 int Port::isNan(double r)
 {
+#if _MSC_VER >= 1900
+    return ::isnan(r);
+#else
     return ::_isnan(r);
+#endif
 }
 
 int Port::isNan(longdouble r)
 {
+#if IN_LLVM
+    return ::isnan(r);
+#else
     return ::_isnan(r);
+#endif
 }
 
 int Port::isSignallingNan(double r)
@@ -239,7 +275,11 @@ int Port::isSignallingNan(longdouble r)
 
 int Port::isInfinity(double r)
 {
+#if _MSC_VER >= 1900
+    return ::isinf(r);
+#else
     return (::_fpclass(r) & (_FPCLASS_NINF | _FPCLASS_PINF));
+#endif
 }
 
 longdouble Port::sqrt(longdouble x)
@@ -257,9 +297,20 @@ int Port::fequal(longdouble x, longdouble y)
     /* In some cases, the REALPAD bytes get garbage in them,
      * so be sure and ignore them.
      */
-    return memcmp(&x, &y, 10) == 0;
+    return memcmp(&x, &y, Target::realsize - Target::realpad) == 0;
+}
+
+#if IN_LLVM
+void Port::yl2x_impl(longdouble* x, longdouble* y, longdouble* res)
+{
+    llvm_unreachable("Port::yl2x_impl");
 }
 
+void Port::yl2xp1_impl(longdouble* x, longdouble* y, longdouble* res)
+{
+    llvm_unreachable("Port::yl2xp1_impl");
+}
+#else
 #if _M_IX86
 void Port::yl2x_impl(longdouble* x, longdouble* y, longdouble* res)
 {
@@ -319,6 +370,7 @@ void Port::yl2xp1_impl(longdouble* x, longdouble* y, longdouble* res)
 }
 
 #endif
+#endif
 
 char *Port::strupr(char *s)
 {
@@ -337,6 +389,9 @@ int Port::stricmp(const char *s1, const char *s2)
 
 float Port::strtof(const char *p, char **endp)
 {
+#if _MSC_VER >= 1900
+    return ::strtof(p, endp); // C99 conformant since VS 2015
+#else
     if(endp)
         return static_cast<float>(::strtod(p, endp)); // does not set errno for underflows, but unused
 
@@ -345,10 +400,14 @@ float Port::strtof(const char *p, char **endp)
     if (res == _UNDERFLOW)
         errno = ERANGE;
     return flt.f;
+#endif
 }
 
 double Port::strtod(const char *p, char **endp)
 {
+#if _MSC_VER >= 1900
+    return ::strtod(p, endp); // C99 conformant since VS 2015
+#else
     if(endp)
         return ::strtod(p, endp); // does not set errno for underflows, but unused
 
@@ -357,6 +416,7 @@ double Port::strtod(const char *p, char **endp)
     if (res == _UNDERFLOW)
         errno = ERANGE;
     return dbl.x;
+#endif
 }
 
 // from backend/strtold.c, renamed to avoid clash with decl in stdlib.h
@@ -364,7 +424,19 @@ longdouble strtold_dm(const char *p,char **endp);
 
 longdouble Port::strtold(const char *p, char **endp)
 {
+#if IN_LLVM
+#if _MSC_VER >= 1900
+    return ::strtold(p, endp); // C99 conformant since VS 2015
+#else
+    // MSVC strtold() before VS 2015 does not support hex float strings. Just
+    // use the function provided by LLVM because we going to use it anyway.
+    llvm::APFloat val(llvm::APFloat::IEEEdouble, llvm::APFloat::uninitialized);
+    val.convertFromString(llvm::StringRef(p), llvm::APFloat::rmNearestTiesToEven);
+    return val.convertToDouble();
+#endif
+#else
     return ::strtold_dm(p, endp);
+#endif
 }
 
 #endif
@@ -579,7 +651,7 @@ longdouble Port::strtold(const char *p, char **endp)
 
 #endif
 
-#if __linux__ || __APPLE__ || __FreeBSD__ || __OpenBSD__
+#if __linux__ || __APPLE__ || __FreeBSD__ || __OpenBSD__ || __DragonFly__ || __HAIKU__
 
 #include <math.h>
 #if __linux__
@@ -599,6 +671,7 @@ longdouble Port::strtold(const char *p, char **endp)
 #include <wchar.h>
 #include <float.h>
 #include <assert.h>
+#include "target.h"
 
 double Port::nan;
 longdouble Port::ldbl_nan;
@@ -629,28 +702,91 @@ static PortInitializer portinitializer;
 
 PortInitializer::PortInitializer()
 {
+#if IN_LLVM
+    union
+    {   unsigned int ui[2];
+        double d;
+    } nan =
+#if __LITTLE_ENDIAN__
+    {{ 0, 0x7FF80000 }};
+#else
+    {{ 0x7FF80000, 0 }};
+#endif
+#else
     union
     {   unsigned int ui[2];
         double d;
     } nan = {{ 0, 0x7FF80000 }};
-
+#endif
     Port::nan = nan.d;
     assert(!signbit(Port::nan));
 
+#if IN_LLVM
+    if (sizeof(double) == sizeof(longdouble))
+    {
+        // double and longdouble are same type.
+        // E.g. on ARM.
+        Port::ldbl_nan = Port::nan;
+    }
+    else
+    {
+        union
+        {   unsigned int ui[4];
+            longdouble ld;
+        } ldbl_nan =
+#if __LITTLE_ENDIAN__
+        {{ 0, 0xC0000000, 0x7FFF, 0}};
+#else
+        {{ 0, 0x7FFF, 0xC0000000, 0}};
+#endif
+        Port::ldbl_nan = ldbl_nan.ld;
+    }
+#else
     union
     {   unsigned int ui[4];
         longdouble ld;
     } ldbl_nan = {{ 0, 0xC0000000, 0x7FFF, 0}};
-
     Port::ldbl_nan = ldbl_nan.ld;
+#endif
+
     assert(!signbit(Port::ldbl_nan));
 
+#if IN_LLVM
+    if (sizeof(double) == sizeof(longdouble))
+    {
+        // double and longdouble are same type.
+        // E.g. on ARM.
+        union
+        {   unsigned int ui[2];
+            double d;
+        } snan =
+#if __LITTLE_ENDIAN__
+        {{ 0, 0x7FFC0000 }};
+#else
+        {{ 0x7FFC0000, 0 }};
+#endif
+        Port::snan = snan.d;
+    }
+    else
+    {
+        union
+        {   unsigned int ui[4];
+            longdouble     ld;
+        } snan =
+    #if __LITTLE_ENDIAN__
+        {{ 0, 0xA0000000, 0x7FFF, 0 }};
+    #else
+        {{ 0, 0x7FFF, 0xA0000000, 0 }};
+    #endif
+        Port::snan = snan.ld;
+    }
+#else
     union
     {   unsigned int ui[4];
         longdouble     ld;
     } snan = {{ 0, 0xA0000000, 0x7FFF, 0 }};
-
     Port::snan = snan.ld;
+#endif
 
 #if __FreeBSD__ && __i386__
     // LDBL_MAX comes out as infinity. Fix.
@@ -670,7 +806,7 @@ int Port::isNan(double r)
 #else
     return __inline_isnan(r);
 #endif
-#elif __FreeBSD__ || __OpenBSD__
+#elif __HAIKU__ || __FreeBSD__ || __OpenBSD__ || __DragonFly__
     return isnan(r);
 #else
     #undef isnan
@@ -686,7 +822,7 @@ int Port::isNan(longdouble r)
 #else
     return __inline_isnan(r);
 #endif
-#elif __FreeBSD__ || __OpenBSD__
+#elif __HAIKU__ || __FreeBSD__ || __OpenBSD__ || __DragonFly__
     return isnan(r);
 #else
     #undef isnan
@@ -714,7 +850,7 @@ int Port::isInfinity(double r)
 {
 #if __APPLE__
     return fpclassify(r) == FP_INFINITE;
-#elif __FreeBSD__ || __OpenBSD__
+#elif __HAIKU__ || __FreeBSD__ || __OpenBSD__ || __DragonFly__
     return isinf(r);
 #else
     #undef isinf
@@ -729,7 +865,7 @@ longdouble Port::sqrt(longdouble x)
 
 longdouble Port::fmodl(longdouble x, longdouble y)
 {
-#if __FreeBSD__ && __FreeBSD_version < 800000 || __OpenBSD__
+#if __FreeBSD__ && __FreeBSD_version < 800000 || __OpenBSD__ || __DragonFly__
     return ::fmod(x, y);        // hack for now, fix later
 #else
     return ::fmodl(x, y);
@@ -741,7 +877,7 @@ int Port::fequal(longdouble x, longdouble y)
     /* In some cases, the REALPAD bytes get garbage in them,
      * so be sure and ignore them.
      */
-    return memcmp(&x, &y, 10) == 0;
+    return memcmp(&x, &y, Target::realsize - Target::realpad) == 0;
 }
 
 #if __i386 || __x86_64__
@@ -956,6 +1092,36 @@ int Port::fequal(longdouble x, longdouble y)
     return memcmp(&x, &y, 10) == 0;
 }
 #if __i386
+#if IN_LLVM
+// There seems to be an issue with register usage if compiled as PIC.
+void Port::yl2x_impl(long double* x, long double* y, long double* res)
+{
+    __asm__ volatile("movl %0, %%eax;"    // move x, y, res to registers
+                     "movl %1, %%ecx;"
+                     "fldt (%%edx);"      // push *y and *x to the FPU stack
+                     "fldt (%%eax);"      // "t" suffix means tbyte
+                     "movl %2, %%eax;"
+                     "fyl2x;"             // do operation and wait
+                     "fstpt (%%eax)"      // pop result to a *res
+                     :                          // output: empty
+                     :"r"(x), "r"(y), "r"(res)  // input: x => %0, y => %1, res => %2
+                     :"%eax", "%ecx", "%eax");  // clobbered register: eax, ecx, eax
+}
+
+void Port::yl2xp1_impl(long double* x, long double* y, long double* res)
+{
+    __asm__ volatile("movl %0, %%eax;"    // move x, y, res to registers
+                     "movl %1, %%ecx;"
+                     "fldt (%%ecx);"      // push *y and *x to the FPU stack
+                     "fldt (%%eax);"      // "t" suffix means tbyte
+                     "movl %2, %%eax;"
+                     "fyl2xp1;"            // do operation and wait
+                     "fstpt (%%eax)"      // pop result to a *res
+                     :                          // output: empty
+                     :"r"(x), "r"(y), "r"(res)  // input: x => %0, y => %1, res => %2
+                     :"%eax", "%ecx", "%eax");  // clobbered register: eax, ecx, eax
+}
+#else
 void Port::yl2x_impl(long double* x, long double* y, long double* res)
 {
     __asm__ volatile("movl %0, %%eax;"    // move x, y, res to registers
@@ -983,7 +1149,7 @@ void Port::yl2xp1_impl(long double* x, long double* y, long double* res)
                      :"r"(x), "r"(y), "r"(res)  // input: x => %0, y => %1, res => %2
                      :"%eax", "%ebx", "%ecx");  // clobbered register: eax, ebc, ecx
 }
-
+#endif
 #elif __x86_64__
 void Port::yl2x_impl(long double* x, long double* y, long double* res)
 {
diff --git a/src/root/port.h b/src/root/port.h
index 34c3c75..e3b06ef 100644
--- a/src/root/port.h
+++ b/src/root/port.h
@@ -13,7 +13,11 @@
 // Portable wrapper around compiler/system specific things.
 // The idea is to minimize #ifdef's in the app code.
 
+#if IN_LLVM
+#include <cstdlib>
+#else
 #include <stdlib.h> // for alloca
+#endif
 #include <stdint.h>
 
 #include "longdouble.h"
diff --git a/src/root/root.h b/src/root/root.h
index bf4f1e1..490def0 100644
--- a/src/root/root.h
+++ b/src/root/root.h
@@ -14,6 +14,16 @@
 #pragma once
 #endif
 
+#if IN_LLVM
+#ifndef IS_PRINTF
+# ifdef __GNUC__
+#  define IS_PRINTF(FMTARG) __attribute((__format__(__printf__, (FMTARG), (FMTARG)+1)))
+# else
+#  define IS_PRINTF(FMTARG)
+# endif
+#endif
+#endif
+
 #include "object.h"
 
 #include "filename.h"
diff --git a/src/root/speller.c b/src/root/speller.c
index eba4e9b..aecf16f 100644
--- a/src/root/speller.c
+++ b/src/root/speller.c
@@ -15,6 +15,8 @@
 
 #if __sun || _MSC_VER
 #include <alloca.h>
+#elif __MINGW32__
+#include <malloc.h>
 #endif
 
 #include "speller.h"
diff --git a/src/scope.c b/src/scope.c
index 3d130b2..6f74f7e 100644
--- a/src/scope.c
+++ b/src/scope.c
@@ -20,9 +20,9 @@
 #include "mars.h"
 #include "init.h"
 #include "identifier.h"
-#include "scope.h"
 #include "attrib.h"
 #include "dsymbol.h"
+#include "scope.h"
 #include "declaration.h"
 #include "statement.h"
 #include "aggregate.h"
@@ -303,8 +303,12 @@ unsigned *Scope::saveFieldInit()
     {
         size_t dim = fieldinit_dim;
         fi = (unsigned *)mem.xmalloc(sizeof(unsigned) * dim);
+#if IN_LLVM // ASan
+        memcpy(fi, fieldinit, sizeof(*fi) * dim);
+#else
         for (size_t i = 0; i < dim; i++)
             fi[i] = fieldinit[i];
+#endif
     }
     return fi;
 }
diff --git a/src/scope.h b/src/scope.h
index 5bdea22..953ba78 100644
--- a/src/scope.h
+++ b/src/scope.h
@@ -35,6 +35,11 @@ class TemplateInstance;
 
 #include "dsymbol.h"
 
+#if IN_LLVM
+struct EnclosingHandler;
+class AnonDeclaration;
+#endif
+
 #if __GNUC__
 // Requires a full definition for LINK
 #include "mars.h"
diff --git a/src/statement.c b/src/statement.c
index d02bcca..ac5acf3 100644
--- a/src/statement.c
+++ b/src/statement.c
@@ -240,10 +240,16 @@ int Statement::blockExit(FuncDeclaration *func, bool mustNotThrow)
 
         void visit(Statement *s)
         {
+#if IN_LLVM
+            std::string msg("Statement::blockExit: ");
+            msg.append(s->toChars());
+            llvm_unreachable(msg.c_str());
+#else
             printf("Statement::blockExit(%p)\n", s);
             printf("%s\n", s->toChars());
             assert(0);
             result = BEany;
+#endif
         }
 
         void visit(ErrorStatement *s)
@@ -1285,7 +1291,11 @@ Statement *CompoundStatement::semantic(Scope *sc)
             goto Lagain;
         }
     }
-    if (statements->dim == 1)
+    if (statements->dim == 1
+#if IN_LLVM
+        && !isCompoundAsmBlockStatement()
+#endif
+    )
     {
         return (*statements)[0];
     }
@@ -2395,6 +2405,10 @@ Statement *ForeachStatement::semantic(Scope *sc)
 
                 p->type = p->type->semantic(loc, sc);
                 p->type = p->type->addStorageClass(p->storageClass);
+#if IN_LLVM
+                // Type of parameter may be different; see below
+                Type *para_type = p->type;
+#endif
                 if (tfld)
                 {
                     Parameter *prm = Parameter::getNth(tfld->parameters, i);
@@ -2424,13 +2438,37 @@ Statement *ForeachStatement::semantic(Scope *sc)
                 LcopyArg:
                     id = Identifier::generateId("__applyArg", (int)i);
 
+#if IN_LLVM
+                    // In case of a foreach loop on an array the index passed
+                    // to the delegate is always of type size_t. The type of
+                    // the parameter must be changed to size_t and a cast to
+                    // the type used must be inserted. Otherwise the index is
+                    // always 0 on a big endian architecture. This fixes
+                    // issue #326.
+                    Initializer *ie;
+                    if (dim == 2 && i == 0 && (tab->ty == Tarray || tab->ty == Tsarray))
+                    {
+                        para_type = Type::tsize_t;
+                        ie = new ExpInitializer(Loc(),
+                                 new CastExp(Loc(),
+                                     new IdentifierExp(Loc(), id), p->type));
+                    }
+                    else
+                        ie = new ExpInitializer(Loc(), new IdentifierExp(Loc(), id));
+#else
                     Initializer *ie = new ExpInitializer(Loc(), new IdentifierExp(Loc(), id));
+#endif
                     VarDeclaration *v = new VarDeclaration(Loc(), p->type, p->ident, ie);
                     v->storage_class |= STCtemp;
                     s = new ExpStatement(Loc(), v);
+
                     body = new CompoundStatement(loc, s, body);
                 }
+#if IN_LLVM
+                params->push(new Parameter(stc, para_type, id, NULL));
+#else
                 params->push(new Parameter(stc, p->type, id, NULL));
+#endif
             }
             // Bugzilla 13840: Throwable nested function inside nothrow function is acceptable.
             StorageClass stc = mergeFuncAttrs(STCsafe | STCpure | STCnogc, func);
@@ -3176,6 +3214,17 @@ Statement *PragmaStatement::semantic(Scope *sc)
         }
 #endif
     }
+#if IN_LLVM
+    // FIXME Move to pragma.cpp
+    else if (ident == Id::LDC_allow_inline)
+    {
+        sc->func->allowInlining = true;
+    }
+    else if (ident == Id::LDC_never_inline)
+    {
+        sc->func->neverInline = true;
+    }
+#endif
     else if (ident == Id::startaddress)
     {
         if (!args || args->dim != 1)
@@ -3466,6 +3515,10 @@ CaseStatement::CaseStatement(Loc loc, Expression *exp, Statement *s)
     this->statement = s;
     index = 0;
     cblock = NULL;
+#if IN_LLVM
+    bodyBB = NULL;
+    llvmIdx = NULL;
+#endif
 }
 
 Statement *CaseStatement::syntaxCopy()
@@ -3693,6 +3746,8 @@ DefaultStatement::DefaultStatement(Loc loc, Statement *s)
     this->statement = s;
 #ifdef IN_GCC
     cblock = NULL;
+#elif IN_LLVM
+    bodyBB = NULL;
 #endif
 }
 
@@ -3767,6 +3822,9 @@ GotoCaseStatement::GotoCaseStatement(Loc loc, Expression *exp)
 {
     cs = NULL;
     this->exp = exp;
+#if IN_LLVM
+    sw = NULL;
+#endif
 }
 
 Statement *GotoCaseStatement::syntaxCopy()
@@ -3782,6 +3840,9 @@ Statement *GotoCaseStatement::semantic(Scope *sc)
         return new ErrorStatement();
     }
 
+#if IN_LLVM
+    sw = sc->sw;
+#endif
     if (exp)
     {
         exp = exp->semantic(sc);
@@ -4195,10 +4256,14 @@ Statement *BreakStatement::semantic(Scope *sc)
                     error("cannot break out of finally block");
                 else
                 {
+#if IN_LLVM
+                    this->target = ls;
+#endif
                     ls->breaks = true;
                     return this;
                 }
                 return new ErrorStatement();
+
             }
         }
         error("enclosing label '%s' for break not found", ident->toChars());
@@ -4288,7 +4353,14 @@ Statement *ContinueStatement::semantic(Scope *sc)
                 else if (ls->tf != sc->tf)
                     error("cannot continue out of finally block");
                 else
+#if IN_LLVM
+                {
+                    this->target = ls;
+#endif
                     return this;
+#if IN_LLVM
+                }
+#endif
                 return new ErrorStatement();
             }
         }
@@ -5067,7 +5139,11 @@ bool GotoStatement::checkLabel()
         }
     }
 
+#if !IN_LLVM
     if (label->statement->tf != tf)
+#else
+    if (label->statement && label->statement->tf != tf)
+#endif
     {
         error("cannot goto in or out of finally block");
         return true;
@@ -5210,6 +5286,7 @@ LabelDsymbol *LabelDsymbol::isLabel()           // is this a LabelDsymbol()?
     return this;
 }
 
+#if !IN_LLVM
 
 /************************ AsmStatement ***************************************/
 
@@ -5229,12 +5306,17 @@ Statement *AsmStatement::syntaxCopy()
     return new AsmStatement(loc, tokens);
 }
 
+#endif
+
 /************************ CompoundAsmStatement ***************************************/
 
 CompoundAsmStatement::CompoundAsmStatement(Loc loc, Statements *s, StorageClass stc)
     : CompoundStatement(loc, s)
 {
     this->stc = stc;
+#if IN_LLVM
+    abiret = NULL;
+#endif
 }
 
 CompoundAsmStatement *CompoundAsmStatement::syntaxCopy()
diff --git a/src/statement.h b/src/statement.h
index ce4a2f6..d8691aa 100644
--- a/src/statement.h
+++ b/src/statement.h
@@ -48,14 +48,34 @@ class TryFinallyStatement;
 class CaseStatement;
 class DefaultStatement;
 class LabelStatement;
+#if IN_LLVM
+class CaseStatement;
+class LabelStatement;
+class SynchronizedStatement;
+#endif
+
+#if IN_LLVM
+namespace llvm
+{
+    class Value;
+    class BasicBlock;
+    class ConstantInt;
+}
+#endif
 
 // Back end
+
 #ifdef IN_GCC
 typedef union tree_node block;
+#elif IN_LLVM
+class DValue;
+typedef DValue elem;
+struct AsmCode;
+typedef AsmCode code;
 #else
 struct block;
-#endif
 struct code;
+#endif
 
 bool inferAggregate(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply);
 bool inferApplyArgTypes(ForeachStatement *fes, Scope *sc, Dsymbol *&sapply);
@@ -80,6 +100,7 @@ class Statement : public RootObject
 {
 public:
     Loc loc;
+    virtual ~Statement() {}
 
     Statement(Loc loc);
     virtual Statement *syntaxCopy();
@@ -116,6 +137,11 @@ public:
     virtual LabelStatement *isLabelStatement() { return NULL; }
     virtual DtorExpStatement *isDtorExpStatement() { return NULL; }
     virtual void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    virtual CompoundAsmStatement *isCompoundAsmBlockStatement() { return NULL; }
+    virtual CompoundAsmStatement* endsWithAsm();
+#endif
 };
 
 /** Any Statement that fails semantic() or has a component that is an ErrorExp or
@@ -203,6 +229,10 @@ public:
 
     CompoundStatement *isCompoundStatement() { return this; }
     void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    virtual CompoundAsmStatement* endsWithAsm();
+#endif
 };
 
 class CompoundDeclarationStatement : public CompoundStatement
@@ -448,6 +478,11 @@ public:
     CaseStatement *isCaseStatement() { return this; }
 
     void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    llvm::BasicBlock* bodyBB;
+    llvm::Value* llvmIdx;
+#endif
 };
 
 
@@ -479,6 +514,10 @@ public:
     DefaultStatement *isDefaultStatement() { return this; }
 
     void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    llvm::BasicBlock* bodyBB;
+#endif
 };
 
 class GotoDefaultStatement : public Statement
@@ -498,6 +537,7 @@ class GotoCaseStatement : public Statement
 public:
     Expression *exp;            // NULL, or which case to goto
     CaseStatement *cs;          // case statement it resolves to
+    SwitchStatement *sw;
 
     GotoCaseStatement(Loc loc, Expression *exp);
     Statement *syntaxCopy();
@@ -538,6 +578,11 @@ public:
     Statement *semantic(Scope *sc);
 
     void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    // LDC: only set if ident is set: label statement to jump to
+    LabelStatement *target;
+#endif
 };
 
 class ContinueStatement : public Statement
@@ -550,6 +595,11 @@ public:
     Statement *semantic(Scope *sc);
 
     void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    // LDC: only set if ident is set: label statement to jump to
+    LabelStatement *target;
+#endif
 };
 
 class SynchronizedStatement : public Statement
@@ -742,6 +792,11 @@ public:
     }
 
     void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    // non-zero if this is a branch, contains the target label
+    LabelDsymbol* isBranchToLabel;
+#endif
 };
 
 // a complete asm {} block
@@ -756,6 +811,13 @@ public:
     Statements *flatten(Scope *sc);
 
     void accept(Visitor *v) { v->visit(this); }
+#if IN_LLVM
+    CompoundStatement *isCompoundStatement() { return NULL; }
+    CompoundAsmStatement *isCompoundAsmBlockStatement() { return this; }
+
+    CompoundAsmStatement* endsWithAsm();
+    llvm::Value* abiret;
+#endif
 };
 
 class ImportStatement : public Statement
diff --git a/src/struct.c b/src/struct.c
index 6fcb204..3db8c30 100644
--- a/src/struct.c
+++ b/src/struct.c
@@ -166,8 +166,10 @@ AggregateDeclaration::AggregateDeclaration(Loc loc, Identifier *id)
     aggNew = NULL;
     aggDelete = NULL;
 
+#if IN_DMD
     stag = NULL;
     sinit = NULL;
+#endif
     enclosing = NULL;
     vthis = NULL;
 
diff --git a/src/template.c b/src/template.c
index 3ec65c7..92c6852 100644
--- a/src/template.c
+++ b/src/template.c
@@ -36,6 +36,11 @@
 #include "attrib.h"
 #include "tokens.h"
 
+#if IN_LLVM
+#include "gen/pragma.h"
+void DtoOverloadedIntrinsicName(TemplateInstance* ti, TemplateDeclaration* td, std::string& name);
+#endif
+
 #define LOG     0
 
 #define IDX_NOTFOUND (0x12345678)               // index is not found
@@ -478,9 +483,17 @@ Dsymbol *TemplateDeclaration::syntaxCopy(Dsymbol *)
         for (size_t i = 0; i < p->dim; i++)
             (*p)[i] = (*parameters)[i]->syntaxCopy();
     }
+#if IN_LLVM
+    TemplateDeclaration *td = new TemplateDeclaration(loc, ident, p,
+        constraint ? constraint->syntaxCopy() : NULL,
+        Dsymbol::arraySyntaxCopy(members), ismixin, literal);
+    td->intrinsicName = intrinsicName;
+    return td;
+#else
     return new TemplateDeclaration(loc, ident, p,
         constraint ? constraint->syntaxCopy() : NULL,
         Dsymbol::arraySyntaxCopy(members), ismixin, literal);
+#endif
 }
 
 void TemplateDeclaration::semantic(Scope *sc)
@@ -5785,7 +5798,11 @@ void TemplateInstance::tryExpandMembers(Scope *sc2)
     static int nest;
     // extracted to a function to allow windows SEH to work without destructors in the same function
     //printf("%d\n", nest);
+#if IN_LLVM
+    if (++nest > global.params.nestedTmpl)
+#else
     if (++nest > 500)
+#endif
     {
         global.gag = 0;                 // ensure error message gets printed
         error("recursive expansion");
@@ -6085,6 +6102,21 @@ Lerror:
             //printf("'%s', '%s'\n", s->ident->toChars(), tempdecl->ident->toChars());
             //printf("setting aliasdecl\n");
             aliasdecl = s;
+
+#if IN_LLVM
+                // LDC propagate internal information
+                if (tempdecl->llvmInternal) {
+                    s->llvmInternal = tempdecl->llvmInternal;
+                    if (FuncDeclaration* fd = s->isFuncDeclaration()) {
+                        if (fd->llvmInternal == LLVMintrinsic) {
+                            DtoOverloadedIntrinsicName(this, tempdecl, fd->intrinsicName);
+                            fd->mangleOverride = strdup(fd->intrinsicName.c_str());
+                        }
+                        else
+                            fd->intrinsicName = tempdecl->intrinsicName;
+                    }
+                }
+#endif
         }
     }
 
@@ -6218,7 +6250,11 @@ Lerror:
         while (ti && !ti->deferred && ti->tinst)
         {
             ti = ti->tinst;
+#if IN_LLVM
+            if (++nest > global.params.nestedTmpl)
+#else
             if (++nest > 500)
+#endif
             {
                 global.gag = 0;            // ensure error message gets printed
                 error("recursive expansion");
@@ -8355,7 +8391,11 @@ void TemplateMixin::semantic(Scope *sc)
 
     static int nest;
     //printf("%d\n", nest);
+#if IN_LLVM
+    if (++nest > global.params.nestedTmpl)
+#else
     if (++nest > 500)
+#endif
     {
         global.gag = 0;                 // ensure error message gets printed
         error("recursive expansion");
diff --git a/src/template.h b/src/template.h
index b6c8f82..a3fa271 100644
--- a/src/template.h
+++ b/src/template.h
@@ -16,6 +16,9 @@
 #pragma once
 #endif /* __DMC__ */
 
+#if IN_LLVM
+#include <string>
+#endif
 #include "root.h"
 #include "arraytypes.h"
 #include "dsymbol.h"
@@ -113,6 +116,11 @@ public:
     bool isOverloadable();
 
     void accept(Visitor *v) { v->visit(this); }
+
+#if IN_LLVM
+    // LDC
+    std::string intrinsicName;
+#endif
 };
 
 /* For type-parameter:
